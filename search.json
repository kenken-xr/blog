[{"title":"20230207","url":"/blog/2023/02/08/20230207/","content":"今天吃什么吃小炒\n\n","categories":["今天在腾讯吃什么"]},{"title":"20230208","url":"/blog/2023/02/08/20230208/","content":"今天吃什么吃水煎包\n吃水煮鱼\n吃蒸菜\n看风景\n","categories":["今天在腾讯吃什么"]},{"title":"20230209","url":"/blog/2023/02/10/20230209/","content":"今天吃什么吃肠粉\n吃鸭腿饭\n吃蒸菜\n","categories":["今天在腾讯吃什么"]},{"title":"20230213","url":"/blog/2023/02/13/20230213/","content":"今天吃什么吃南瓜饼\n\n吃泡面没有图\n吃麻辣香锅\n","categories":["今天在腾讯吃什么"]},{"title":"20230215","url":"/blog/2023/02/15/20230215/","content":"今天吃什么吃红糖发糕\n\n吃蒸菜\n\n","categories":["今天在腾讯吃什么"]},{"title":"20230216","url":"/blog/2023/02/16/20230216/","content":"今天吃什么吃牛筋丸粿条\n\n中午吃水煮肉片忘了拍\n晚上在吵架没有拍\n","categories":["今天在腾讯吃什么"]},{"title":"20230217","url":"/blog/2023/02/17/20230217/","content":"今天吃什么吃米酒汤圆\n吃水煮肉片\n\n吃意大利面喝奶茶\n\n\n","categories":["今天在腾讯吃什么","吃了什么好吃的"]},{"title":"20230219","url":"/blog/2023/02/19/20230219/","content":"今天吃什么吃红烧鱼\n\n吃点水果\n\n","categories":["今天在腾讯吃什么","吃了什么好吃的"]},{"title":"20230221","url":"/blog/2023/02/20/20230221/","content":"今天吃什么吃发糕\n\n吃排骨\n\n吃炒饭\n一起逛公园\n\n\n\n\n\n","categories":["今天在腾讯吃什么","吃了什么好吃的"]},{"title":"20230220","url":"/blog/2023/02/20/20230220/","content":"今天吃什么吃豆沙饼\n\n中午困死了没吃直接回去睡\n吃烧腊\n\n吃烧饼\n\n","categories":["今天在腾讯吃什么","吃了什么好吃的"]},{"title":"20230222","url":"/blog/2023/02/22/20230222/","content":"今天吃什么吃南瓜饼\n吃水煮肉片\n晚上去吃了达美乐\n照了很多照片\n\n\n\n\n\n\n\n\n\n","categories":["今天在腾讯吃什么"]},{"title":"20230224","url":"/blog/2023/02/24/20230224/","content":"今天吃什么吃豆沙饼\n吃小馄饨\n吃麻辣香锅\n早上遇到的麦当劳小车\n","categories":["今天在腾讯吃什么"]},{"title":"20230227","url":"/blog/2023/02/27/20230227/","content":"今天吃什么吃蒸饺\n\n吃沙拉一般般 \n\n超能鹿战队\n\n\n吃肉夹馍\n\n","categories":["今天在腾讯吃什么"]},{"title":"20230228","url":"/blog/2023/02/28/20230228/","content":"今天吃什么吃菜包子不好吃\n\n吃沙拉这个好好吃\n\n染七沙拉.三文治.热轻食\n\n\n吃黑椒牛排好吃\n","categories":["今天在腾讯吃什么"]},{"title":"20230908","url":"/blog/2023/09/08/9-08/","content":"Bug搜索出的视频不能播放拉取过来的视频有远端的clip，显示黑屏也无法进行操作\n在搜索结果页SearchResultActivity像首页一样过滤出本地的时候，同时在后台进行拉取远端视频\nprivate suspend fun doSearchBySearchGroupList(    keyArray: List&lt;SearchGroup&gt;,    replaceAll: Boolean = true,    beginCursor: String = \"\") {    val log = logger.withTag(TAG, \"Search\", \"searchByLabelKeyArray\")    log.i(\"keyArray = $keyArray, replaceAll = $replaceAll, beginCursor = $beginCursor\")    if (!replaceAll &amp;&amp; beginCursor.isEmpty()) {        logger.w(TAG, \"ignore not replaceAll AND beginCursor empty to prevent repeat item\")        return    }    uiActionRequiredEvent.postValue(UiAction(UI_ACTION_BEGIN_REFRESH))    sideLoadLabelKeys(keyArray) // 缓存搜索关键字    log.d(\"begin refresh\")    val list = performOnIOWithDefault(emptyList()) {        val resultClipsList = ArrayList&lt;Clip&gt;()        var currentCursor = beginCursor        do {            log.d(\"getClipsListByLabel, c = $currentCursor, size = ${resultClipsList.size}\")            val allKeys = ArrayList&lt;String&gt;()            keyArray.forEach {                it.keys.forEach { k -&gt;                    allKeys.add(k)                }            }            val resp = sdk.getClipsListByLabel(currentCursor, allKeys).await()            resp.nextCursor.run {                log.d(\"getClipsListByLabel, nextCursor = $this\")                currentCursor = this                nextCursor = this            }            // 同框筛选            val filteredResultClipList = resp.list?.filter { clip -&gt;                clip.containsSearchGroups(keyArray)            }            filteredResultClipList?.let { resultClipsList.addAll(it) }        } while (resultClipsList.size &lt; 30 /* 拍脑袋想的，填满屏幕 */ &amp;&amp; currentCursor.isNotEmpty())        resultClipsList    }  //------------------------------------------过滤-----------------------------------------------//    // 过滤出本地视频    val localList = list.filter { it.playMode == Clip.CLIP_PLAY_MODE_LOCAL }.toMutableList()    if (replaceAll &amp;&amp; localList.isEmpty()) {        // fixme: 目前是因为replaceAll什么都刷不出来就返回，不是replaceAll的话列表已经有数据了，就不返回        uiActionRequiredEvent.postValue(UiAction(UI_ACTION_BACK))        log.i(\"no result, back\")    }    if (replaceAll) {        searchResultAdapter.replaceAll(list)    } else {        searchResultAdapter.addAll(localList)    }    withContext(Dispatchers.Main) {        uiActionRequiredEvent.postValue(UiAction(UI_ACTION_END_REFRESH, replaceAll))        log.d(\"end refresh\")    }  //------------------------------------------过滤-----------------------------------------------//}\n\n同时拉取远端视频\n/*** 过滤远端视频资源，同时对远端视频发起拉取*/@SuppressLint(\"CheckResult\")private fun filterPlayList(list: List&lt;Clip&gt;): List&lt;Clip&gt; {  val localList = list.filter { it.playMode == Clip.CLIP_PLAY_MODE_LOCAL }.toMutableList()  val remoteList =      list.filter { it.playMode == Clip.CLIP_PLAY_MODE_REMOTE_DEVICE }.toMutableList()  logger.d(TAG, \"localList size=${localList.size}, remoteList size=${remoteList.size}\")  // 远端拉取  getRemoteList(remoteList)  return localList}/*** 远端拉取视频*/private fun getRemoteList(remoteList: List&lt;Clip&gt;) {  if (remoteList.isEmpty()) {      logger.d(TAG, \"RemoteList is empty.\")      return  }  if (!NetworkUtil.isUsingNotMeteredNetwork(getApplication())) {      logger.d(TAG, \"Not currently connected to Wi-Fi.\")      return  }  // 远端拉取  val avDataPacketList = ArrayList&lt;Observable&lt;AvDataPacket&gt;&gt;()  remoteList.forEach {      val data = it.originalDataList?.get(0)      data?.apply {          avDataPacketList.add(              sdk.getDeviceOriginalData(                  deviceID,                  startTimeMillis,                  endTimeMillis,                  30              )          )      }  }  logger.d(TAG, \"AvDataStreamObservable List size=${avDataPacketList.size}\")  // 通过concat将所有的观察对象串成一条，依次订阅，失败则拉取下一个  Observable.concat(avDataPacketList).onErrorComplete().doOnComplete {      logger.i(TAG, \"fetch remote data complete, but there may be some errors and omissions\")  }.doOnError {      logger.e(TAG, \"error = $it\")  }.subscribe()}\n\n\n\nNew收藏和转发给好友页面限制竖屏9c36ed7672851dfda78b85ee549ff24ab9681b57\n&lt;activity  android:name=\".ui.user.FavoriteActivity\"  android:exported=\"false\"  android:screenOrientation=\"portrait\" /&gt;&lt;activity  android:name=\".ui.share.ListShareToContactActivity\"  android:exported=\"false\"  android:screenOrientation=\"portrait\" /&gt;\n","categories":["有在认真上班"],"tags":["2023 9月记录"]},{"title":"20230911","url":"/blog/2023/09/11/9-11/","content":"New收藏列表跳转到播放后返回定位到当前播放的位置记录当前播放是第几个视频attachFirstVisibleViewHolder中拿到当前播放的position，通过attachPlayer播放视频，在这里传入position参数到VideoFlowViewModel中\nval position = layoutManager.findFirstCompletelyVisibleItemPosition()if (position == RecyclerView.NO_POSITION) return...delegate.attachPlayer(    surface,    clip,    positionResponder = viewHolder,    position)\n\n\n\noverride fun attachPlayer(    surface: Surface,    clip: Clip,    positionResponder: ClipPositionResponder?,    position: Int) {    this@VideoFlowViewModel.attachPlayer(        surface,        clip,        positionResponder = positionResponder,        position = position    )}\n\n\n\nattachPlayer中setPlayerClipDatasource用来播放视频，在这个方法中更新position\n// 更新当前播放的视频下标setCurrentClipPosition(position)\n\n\n\nVideoFlowViewModel中通过静态方法更新参数\nprivate var currentClipPosition: Int = -1fun setCurrentClipPosition(position: Int) { currentClipPosition = position }fun getCurrentClipPosition(): Int { return currentClipPosition }\n\n\n\n拿到最新的视频下标FavoriteFragment\nposition是视频的位置，收藏列表中还包括了日期，要通过position计算出包括日期的下标\n// 当前浏览过的视频的下标val position = VideoFlowViewModel.getCurrentClipPosition()// 包括date的下标val positionNew = viewModel.searchResultAdapter.countDateBeforeClip(position)\n\nFavoriteAdapter\n/** * 通过单独clip的位置返回包括date的位置 * */fun countDateBeforeClip(clipPosition: Int): Int {    var count = 0    var clipCount = 0    for (item in itemList) {        if (item is String) count += 1        else clipCount += 1        if (clipCount == clipPosition + 1) break    }    return count + clipPosition}\n\n\n\n滚动到指定位置if (positionNew &gt; 0) {    if (recyclerView.layoutManager == null || recyclerView.adapter == null) {        logger.d(TAG, \"RecyclerView layout or adapter is not set\")        return    }    // 滚动位置是否在可见范围内    val lastVisiblePosition = layoutManager.findLastVisibleItemPosition()    val rowHeight = if (positionNew &lt; lastVisiblePosition) {        layoutManager.findViewByPosition(positionNew)?.bottom    } else {        resources.displayMetrics.heightPixels    }    /**     * 滚动到最后播放的clip可见位置,再整体移到顶部     * 24 safe_area_top_guide     * 48 导航栏     * 16 recyclerView margin-top     * 96 视频高度     * 4 clip padding-top     * */    recyclerView.scrollToPosition(positionNew)    val scrollDistance = MeasureUtil.dp2px(context, 24f + 48f + 16f + 96f + 4f)    logger.d(TAG, \"onResume height: $rowHeight padding $scrollDistance\")    if (rowHeight != null) {        binding.recyclerView.smoothScrollBy(0, rowHeight - scrollDistance)    }}\n\n\n\nBug由于所有的视频播放都共用一个adapter，存在首页或者搜索页向下刷视频的时候位置会不断更新，导致首次进入收藏页也会导致位置滚动，所以在第一次进入收藏的时候重置位置\noverride fun onCreateView(    inflater: LayoutInflater,    container: ViewGroup?,    savedInstanceState: Bundle?): View {    VideoFlowViewModel.setCurrentClipPosition(DEFAULT_POSITION)}\n\n","categories":["有在认真上班"],"tags":["2023 9月记录"]},{"title":"20230912","url":"/blog/2023/09/12/9-12/","content":"Bug视频流显示拍摄者昵称 非idsuspend fun getUserLikeName(pltUserName: String): String? {    return performOnIOWithDefault(null) {        sdk.getUserLikeNameByPlatformUserName(pltUserName).awaitSingleOrNull()    }}\n\n\n\n适配16:9手机大拿分享接收弹窗整体弄小点\nNew收藏、搜索状态启动大拿分享ResultFlowFragment.kt\noverride fun onResume() {    super.onResume()    viewModel.beginNearbyScan()}override fun onPause() {    super.onPause()    viewModel.endNearbyScan()}\n\n","categories":["有在认真上班"],"tags":["2023 9月记录"]},{"title":"20230913","url":"/blog/2023/09/13/9-13/","content":"BugMP4视频第二次下载导致APP崩溃原因是第一次保存时缓存文件被删除导致再次保存找不到文件\n在最外层判断当前视频是否是MP4，如果是直接返回\nsuspend fun saveVideoToGallery(context: Context, clip: Clip): String {    if (clip.type != Clip.CLIP_TYPE_ORIGINAL_DATA) {        /**         * FIXME: 目前不支持编辑已经是MP4的文件, 暂时全部返回原视频         *  收藏页 -&gt; 添加拍摄者水印         *  非本人拍摄(app内分享) -&gt; 添加拍摄者水印         *  已经有水印(识别视频) -&gt; 直接保存原视频         * */        logger.w(TAG, \"clip type is not original data\")        val nonOriMP4Path = clip.nonOriginalData?.get(Clip.NonOriginalData.KEY_MP4_PATH)        return if (nonOriMP4Path != null &amp;&amp; File(nonOriMP4Path).exists()) {            copyToMediaStore(context, File(nonOriMP4Path))        } else {            \"\"        }    }    return if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) {        saveVideoBeforeQ(context, clip)    } else {        saveVideo(context, clip)    }}\n\n其中copyToMediaStore(context, File(nonOriMP4Path))是用于将视频拷贝到相册\n续9.11 收藏列表跳转到播放后返回定位到当前播放的位置静态变量和静态方法的写法不优雅 改成StartActivityForResult的方式\nVideoFlowViewModel中传递position的值并在SearchResultFlowActivity中观察\nprivate fun setPlayerClipDatasource(    player: IjkMediaPlayer,    clip: Clip,    listener: RawPacketVideoSource.TimeListener? = null,    timeOffset: Long = 0,    position: Int) {    logger.i(TAG, \"setPlayerClipDatasource, $clip\")    // 更新当前播放的视频下标    uiActionUpdateClipPositionLiveData.postValue(        UiAction(            ACTION_UPDATE_CLIP_POSITION,            position        )    )}\n\n\n观察到的时候返回result的值\nflowVM.uiActionUpdateClipPositionLiveData.observe(this) { action -&gt;    if (action == null) return@observe    when (action.what) {        VideoFlowViewModel.ACTION_UPDATE_CLIP_POSITION -&gt; {            (action.param as? Int)?.let { position -&gt;                val resultIntent = Intent().putExtra(                    BaseNavigation.Constants.EXTRA_CURRENT_CLIP_POSITION,                    position                )                setResult(Activity.RESULT_OK, resultIntent)            }        }        else -&gt; {            logger.w(TAG, \"uiActionRequiredEvent, unknown action $action\")        }    }}\n\n\n\nFavoriteAdapter中通过onClick传递当前点击的不包含的日期位置下标，用于跳转的时候从第几个视频开始播放\nfun onClickFavoriteItem(positionInGroup: Int) {    val clipsListJsonString = gson.toJson(favoriteList)    pv.store(EXTRA_FLOW_CLIPS_ARRAY_JSON, clipsListJsonString)    uiActionRequiredEvent.postValue(UiAction(ACTION_CLICK_FAVORITE_ITEM, positionInGroup))}\n\n\n\n\n\nFavoriteFragment中接收值并执行相应操作\n// 当前浏览过的视频的下标private var currentClipPosition: Int = 0private var startFavoriteFlowLauncher =  registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt;      if (result.resultCode == Activity.RESULT_OK) {          currentClipPosition = result.data?.getIntExtra(              BaseNavigation.Constants.EXTRA_CURRENT_CLIP_POSITION,              0          ) ?: 0      } else {          logger.e(TAG, \"startFavoriteFlowLauncher code=${result.resultCode}\")      }  }viewModel.uiActionRequiredEvent.observe(viewLifecycleOwner) {    it ?: return@observe    when (it.what) {        ACTION_CLICK_FAVORITE_ITEM -&gt; {            val positionInGroup = it.param as? Int            val intent = Intent(context, SearchResultFlowActivity::class.java)            intent.putExtra(                BaseNavigation.Constants.EXTRA_FLOW_INITIAL_POSITION_INT,                positionInGroup            )            intent.putExtra(BaseNavigation.Constants.EXTRA_FLOW_NEXT_CURSOR_STRING, \"\")            startFavoriteFlowLauncher.launch(intent)        }    }}\n\n\n\n滚动方法\n/*** * 滚动到最后播放的clip */private fun scrollViewToLastClip(recyclerView: RecyclerView, layoutManager: GridLayoutManager) {    // 包括date的下标    val positionWithDate =        viewModel.searchResultAdapter.countDateBeforeClip(currentClipPosition)    if (positionWithDate &gt; 0) {        if (recyclerView.layoutManager == null || recyclerView.adapter == null) {            logger.d(TAG, \"RecyclerView layout or adapter is not set\")            return        }        // 滚动位置是否在可见范围内        val lastVisiblePosition = layoutManager.findLastVisibleItemPosition()        val rowHeight = if (positionWithDate &lt; lastVisiblePosition) {            layoutManager.findViewByPosition(positionWithDate)?.bottom        } else {            resources.displayMetrics.heightPixels        }        /**         * 滚动到最后播放的clip可见位置,再整体移到顶部         * 24 safe_area_top_guide         * 48 导航栏         * 16 recyclerView margin-top         * 96 视频高度         * 4 clip padding-top         * */        recyclerView.scrollToPosition(positionWithDate)        val scrollDistance = MeasureUtil.dp2px(context, 24f + 48f + 16f + 96f + 4f)        logger.d(TAG, \"onResume height: $rowHeight padding $scrollDistance\")        if (rowHeight != null) {            binding.recyclerView.smoothScrollBy(0, rowHeight - scrollDistance)        }    }}\n\n\n\n\n\n方法写在onResume里存在问题：在滚动后回到收藏页并往下翻视频列表，此时退出app到后台，再次切入应用会触发onResume导致再次滚动\n把滚动方法写到接收到result的时候\nFavoriteFragment\n// 当前浏览过的视频的下标private var startFavoriteFlowLauncher =  registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result -&gt;      if (result.resultCode == Activity.RESULT_OK) {          val currentClipPosition = result.data?.getIntExtra(              BaseNavigation.Constants.EXTRA_CURRENT_CLIP_POSITION,              0          ) ?: 0        /***************写在这里**********************/          scrollViewToLastClip(binding.recyclerView, layoutManager, currentClipPosition)      } else {          logger.e(TAG, \"startFavoriteFlowLauncher code=${result.resultCode}\")      }  }\n\n","categories":["有在认真上班"],"tags":["2023 9月记录"]},{"title":"基本的一些东西","url":"/blog/2023/02/28/%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/","content":"Log运行日志Android 采用Log工具打印日志，它将各类日志划分为五个级:\n\nLog.eE表示错误信息，比如可能导致程序崩溃的异常。\n\nLog.w:表示警告信息。\n\nLog.i:表示一般消息。\n\nLog.d:表示调试信息，可把程序运行时的变量值打印出来，方便跟踪调试。\n\nLog.v:表示冗余信息。\n\n\n工程目录结构App工程目录结构App工程分为两个层次，第一个层次是项目，另一个层次是模块。\n模块依附于项目，每个项目至少有一个模块，也能拥有多个模块。一般所言的“编译运行App”，指的是运行某个模块，而非运行某个项目，因为模块才对应实际的App。\nApp项目下面有两个分类: \n\napp（代表app模块)  下面有3个子目录\nGradle Scripts，主要是工程的编译配置文件\n\n\n\napp（代表app模块）\n\nmanifests子目录，下面只有一个XML文件，即AndroidManifest.xml，它是App的运行配置文件。\n\njava子目录，下面有3个com.example.myapp包，其中第一个包存放当前模块的Java源代码，后面两个包存放测试用的Java代码。\n\nres子目录，存放当前模块的资源文件\n\ndrawable目录存放图形描述文件与图片文件。\nlayout目录存放App页面的布局文件。\nmipmap目录存放App的启动图标。\nvalues目录存放一些常量定义文件，例如字符串常量strings.xml、像素常量dimens.xml、颜色常量colors.xml、样式风格定义styles.xml等。  \n\n\nGradle Scripts\n\nbuild.gradle，该文件分为项目级与模块级两种，用于描述App工程的编译规则。\nproguard-rules.pro，该文件用于描述Java代码的混淆规则。\ngradle.properties，该文件用于配置编译工程的命令行参数，一般无须改动。\nsettings.gradle，该文件配置了需要编译哪些模块。初始内容为include ‘:app’，表示只编译app模块。\nlocal.properties，项目的本地配置文件，它在工程编译时自动生成，用于描述开发者电脑的环境配置，包括SDK的本地路径、NDK的本地路径等。\n\n\n\n\n\n编译配置文件build.gradle项目级别的build.gradle指定了当前项目的总体编译规则，打开该文件在buildscript下面找到repositories和dependencies两个节点，其中repositories节点用于设置Android Studio插件的网络仓库地址，而dependencies节点用于设置gradle插件的版本号。由于官方的谷歌仓库位于国外，下载速度相对较慢，因此可在repositories节点添加阿里云的仓库地址，方便国内开发者下载相关插件。\nbuildscript {  repositories {    // 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件    maven { url 'https://maven.aliyun.com/repository/jcenter' }    maven { url 'https://maven.aliyun.com/repository/google'}    maven { url 'https://maven.aliyun.com/repository/gradle-plugin'}    maven { url 'https://maven.aliyun.com/repository/public'}    google()    jcenter()  } \tdependencies {    // 配置gradle插件版本，下面的版本号就是Android Studio的版本号    classpath 'com.android.tools.build:gradle:4.1.0'  }}\n\n模块级别的build.gradle对应于具体模块，每个模块都有自己的build.gradle，它指定了当前模块的详细编译规则。  \nplugins {    id 'com.android.application'}android {  \t// 指定编译用的SDK版本号。比如30表示使用Android 11.0编译    compileSdk 30,  \t// 指定编译工具的版本号。这里的头两位数字必须与compileSdkVersion保持一致，具体的版本号可在sdk安装目录的“sdk\\build-tools”下找到\t\tbuildToolsVersion \"30.0.3,    defaultConfig {      \t// 指定该模块的应用编号，也就是App的包名        applicationId \"com.dongnaoedu.myapplication\"        // 指定App适合运行的最小SDK版本号。比如19表示至少要在Android 4.4上运行        minSdkVersion 19        // 指定目标设备的SDK版本号。表示App最希望在哪个版本的Android上运行        targetSdkVersion 30        // 指定App的应用版本号        versionCode 1        // 指定App的应用版本名称        versionName \"1.0\"        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'        }    }}// 指定App编译的依赖信息dependencies {    // 指定引用jar包的路径    implementation fileTree(dir: 'libs', include: ['*.jar'])    // 指定编译Android的高版本支持库。如AppCompatActivity必须指定编译appcompat库    //appcompat库各版本见https://mvnrepository.com/artifact/androidx.appcompat/appcompat    implementation 'androidx.appcompat:appcompat:1.2.0'    // 指定单元测试编译用的junit版本号    testImplementation 'junit:junit:4.13'    androidTestImplementation 'androidx.test.ext:junit:1.1.2'    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0}\n\n运行配置文件AndroidManifest.xmlAndroidManifest.xml指定了App的运行配置信息，它是一个XML描述文件  \n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"package=\"com.example.chapter02\"&gt;  &lt;application    android:allowBackup=\"true\"    android:icon=\"@mipmap/ic_launcher\"    android:label=\"@string/app_name\"    android:roundIcon=\"@mipmap/ic_launcher_round\"    android:supportsRtl=\"true\"    android:theme=\"@style/AppTheme\"&gt;    &lt;activity android:name=\".Main2Activity\"&gt;&lt;/activity&gt;    \t&lt;!-- activity节点指定了该App拥有的活动页面信息，其中拥有android.intent.action.MAIN的activity说明它是入口页面 --&gt;      &lt;activity android:name=\".MainActivity\"&gt;        &lt;intent-filter&gt;          &lt;action android:name=\"android.intent.action.MAIN\" /&gt;          &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;        &lt;/intent-filter&gt;      &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;\n\nAndroidManifest.xml的根节点为manifest，它的package属性指定了该App的包名。manifest下面有个application节点\n\nandroid:allowBackup，是否允许应用备份。允许用户备份系统应用和第三方应用的apk安装包和应用数据，以便在刷机或者数据丢失后恢复应用，用户即可通过adb backup和adb restore来进行对应用数据的备份和恢复。为true表示允许，为false则表示不允许。\nandroid:icon，指定App在手机屏幕上显示的图标。\nandroid:label，指定App在手机屏幕上显示的名称。\nandroid:roundIcon，指定App的圆角图标。\nandroid:supportsRtl，是否支持阿拉伯语／波斯语这种从右往左的文字排列顺序。为true表示支持，为false则表示不支持。\nandroid:theme，指定App的显示风格。  \n\napplication下面还有个activity节点，它是活动页面的注册声明，只有在AndroidManifest.xml中正确配置了activity节点，才能在运行时访问对应的活动页面。初始配置的MainActivity正是App的默认主页，之所以说该页面是App主页，是因为它的activity节点内部还配置了以下的过滤信息  \n&lt;intent-filter&gt;  &lt;action android:name=\"android.intent.action.MAIN\" /&gt;  &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;&lt;/intent-filter&gt;\n\n其中action节点设置的android.intent.action.MAIN表示该页面是App的入口页面，启动App时会最先打开该页面。\n而category节点设置的android.intent.category.LAUNCHER决定了是否在手机屏幕上显示App图标，如果同时有两个activity节点内部都设置了android.intent.category.LAUNCHER，那么桌面就会显示两个App图标。  \n","categories":["有在认真上班"],"tags":["Android"]},{"title":"情人节怎么过","url":"/blog/2023/02/14/%E6%83%85%E4%BA%BA%E8%8A%82%E6%80%8E%E4%B9%88%E8%BF%87/","content":"早饭吃了玉米饼\n\n晚上吃了欠死我的螺蛳粉\n\n戴好看的项链\n\n剪了一个视频  \n\n \n\n \n    gotoplayer(\"https://raw.githubusercontent.com/kenken-xr/blog-images/images/images/20230214/%E8%AE%B0%E5%BD%95.mp4\");\n","categories":["今天在腾讯吃什么","每天都要吃饭","认真谈恋爱"]},{"title":"愤怒的小鸟包","url":"/blog/2023/02/04/%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F%E5%8C%85/","content":"红红火火小鸟包\n\n","categories":["每天都有小惊喜"]},{"title":"添加退出二次确认","url":"/blog/2023/02/13/%E6%B7%BB%E5%8A%A0%E9%80%80%E5%87%BA%E4%BA%8C%E6%AC%A1%E7%A1%AE%E8%AE%A4/","content":"新建Fragmentres/layout/dialog_confirm_logout.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;    &lt;/data&gt;    &lt;androidx.coordinatorlayout.widget.CoordinatorLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        tools:background=\"#CFCFCF\"&gt;        &lt;androidx.constraintlayout.widget.ConstraintLayout            android:layout_width=\"@dimen/app_dialog_width\"            android:layout_height=\"wrap_content\"            android:layout_gravity=\"center\"            tools:background=\"#FFFFFF\"&gt;            &lt;androidx.appcompat.widget.AppCompatTextView                android:id=\"@+id/confirm_title\"                android:layout_width=\"match_parent\"                android:layout_height=\"wrap_content\"                android:layout_marginHorizontal=\"24dp\"                android:layout_marginTop=\"24dp\"                android:gravity=\"center\"                android:text=\"确认退出？\"                android:textStyle=\"bold\"                app:layout_constraintEnd_toEndOf=\"parent\"                app:layout_constraintStart_toStartOf=\"parent\"                app:layout_constraintTop_toTopOf=\"parent\" /&gt;            &lt;androidx.appcompat.widget.AppCompatTextView                android:id=\"@+id/confirm_accept\"                android:layout_width=\"match_parent\"                android:layout_height=\"40dp\"                android:layout_marginHorizontal=\"24dp\"                android:layout_marginTop=\"16dp\"                android:background=\"@drawable/bg_rounded_rect\"                android:backgroundTint=\"@color/app_primary\"                android:focusable=\"true\"                android:gravity=\"center\"                android:paddingHorizontal=\"16dp\"                android:text=\"确定\"                android:textColor=\"@color/app_std_text_white\"                android:textSize=\"14sp\"                app:layout_constraintRight_toRightOf=\"parent\"                app:layout_constraintTop_toBottomOf=\"@id/confirm_title\" /&gt;            &lt;androidx.appcompat.widget.AppCompatTextView                android:id=\"@+id/confirm_cancel\"                android:layout_width=\"match_parent\"                android:layout_height=\"wrap_content\"                android:minHeight=\"20dp\"                android:layout_marginHorizontal=\"24dp\"                android:layout_marginTop=\"8dp\"                android:layout_marginBottom=\"24dp\"                android:alpha=\"0.45\"                android:gravity=\"center\"                android:text=\"取消\"                android:textSize=\"12sp\"                app:layout_constraintBottom_toBottomOf=\"parent\"                app:layout_constraintTop_toBottomOf=\"@id/confirm_accept\" /&gt;        &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;    &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;&lt;/layout&gt;\n\n\n添加Fragment绑定com/danale/edge/ui/common/dialog/AcceptConfirmLogoutFragment.kt\npackage com.danale.edge.ui.common.dialogimport android.app.Dialogimport android.content.Contextimport android.os.Bundleimport android.view.LayoutInflaterimport androidx.databinding.DataBindingUtilimport androidx.fragment.app.DialogFragmentimport com.danale.edge.R// Fragmentimport com.danale.edge.databinding.DialogConfirmLogoutBindingclass AcceptConfirmLogoutFragment (val callback: (Int) -&gt; Unit) : DialogFragment() {    companion object {      \t// 定义两种操作         const val ACTION_CONFIRM_LOGOUT = 9001        const val ACTION_CANCEL_LOGOUT = 9002    }    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {        return AcceptConfirmLogout(            callback,            requireContext(),            R.style.Theme_ViewWorld_Dialog        ).apply {            window?.setBackgroundDrawableResource(R.drawable.bg_rounded_rect)        }    }    class AcceptConfirmLogout(        val callback: (Int) -&gt; Unit,        context: Context,        themeResId: Int    ) : Dialog(context, themeResId) {        val binding: DialogConfirmLogoutBinding  // binding        init {            binding = DataBindingUtil.inflate(                LayoutInflater.from(context),                R.layout.dialog_confirm_logout,                null,                false            )          \t// 确认退出            binding.confirmAccept.setOnClickListener {                dismiss()                callback(ACTION_CONFIRM_LOGOUT)            }          \t// 取消退出            binding.confirmCancel.setOnClickListener {                dismiss()                callback(ACTION_CANCEL_LOGOUT)            }            setContentView(binding.root)        }    }}\n\n\n\n二次确认com/danale/edge/ui/user/MyInfoFragment.kt\nimport com.danale.edge.ui.common.dialog.AcceptConfirmLogoutFragment// 退出登录binding.groupLogout.setOnClickListener {  try {      AcceptConfirmLogoutFragment {        when (it) {            AcceptConfirmLogoutFragment.ACTION_CONFIRM_LOGOUT -&gt; {                lifecycleScope.launch {                    viewModel.logout()  // 退出                }            }            AcceptConfirmLogoutFragment.ACTION_CANCEL_LOGOUT -&gt; {                return@AcceptConfirmLogoutFragment            }        }      }.show(parentFragmentManager, \"confirm_logout\")  } catch (e: Exception) {      toastError(e)  }}\n\nlogout是suspend异步函数，需要另起一个协程，写在launch中\n","categories":["有在认真上班"],"tags":["改了什么bug"]},{"title":"漂亮项链和可爱包包","url":"/blog/2023/02/12/%E6%BC%82%E4%BA%AE%E9%A1%B9%E9%93%BE%E5%92%8C%E5%8F%AF%E7%88%B1%E5%8C%85%E5%8C%85/","content":"漂亮项链网上偷的美丽图\n\n\n\n\n自己拍的丑图\n\n\n\n可爱包包\n\n\n","categories":["每天都有小惊喜"]},{"title":"视频导入和导出","url":"/blog/2023/03/24/%E8%A7%86%E9%A2%91%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA/","content":"概述内容由于在视频的算法计算和同步时是一次性计算完成，导致回顾时不能重新定位到需求位置(有人经过、有声音)，需要将视频可以导出，同时可以导入到把视频重新放到pipeline中可复现\n需求\n导出文件 \n有一个用户操作的入口 [分享菜单]  \n导出后是一个mp4完整文件/ 原始数据格式(0000001是一帧的开头，根据标识保存数据)\n\n\n读取文件读成pipeline的输入\n文件转换成一帧\n\n过程pipelineFactoryobject DemoPipelineFactory {    fun createVideoPipeline(        sink: EventSink,        ai: IntelligenceRepository,        logger: Logger    ): LabelPipeline&lt;Bitmap&gt; {        val facePipelineBuilder = LabelPipeline.Builder&lt;List&lt;MarkedFace&gt;&gt;(logger)        val facePipeline = facePipelineBuilder            .sinkTo(sink)            .addOp(HMSFaceVerifier(ai, logger))            .build()        val facePipeSplitter = SplitExtractor(facePipeline, GoogleMLKitFaceDetector(logger))        val videoPipeBuilder = LabelPipeline.Builder&lt;Bitmap&gt;(logger)        return videoPipeBuilder            .sinkTo(sink)            .addOp(facePipeSplitter)\t\t\t\t\t\t// .addOp(HMSSceneDetector()) // TODO 接入新的标签回调            .addOp(TFLiteObjectDetector(ModelName.SSD_MOBILE_NET_V1, ai, logger))            .build()    }    fun createAudioPcmPipeline(        eventSink: EventSink,        intelligenceRepository: IntelligenceRepository,        logger: Logger    ): LabelPipeline&lt;ShortArray&gt; {        val audioPipeBuilder = LabelPipeline.Builder&lt;ShortArray&gt;(logger)        return audioPipeBuilder            .sinkTo(eventSink)            .addOp(YAMNetAudioClassifier(intelligenceRepository, logger))            .build()    }}\n\n\n\nLabelPipeLinecom/danale/edge/intelligence/pipe/LabelPipeline.kt\nopen class LabelPipeline&lt;T : Any&gt;(    private val extractors: List&lt;LabelExtractor&lt;T&gt;&gt;,    private val logger: Logger,    private val providedSink: EventSink?) : Closeable {    companion object {        const val TAG = \"LabelPipeline\"    }    init {        extractors.forEach {            if (providedSink != null) {                logger.i(TAG, \"init, sink ${it.hashCode()} to ${providedSink.hashCode()}\")                it.bindEventSink(providedSink)            }        }    }    fun process(item: T, metaData: LabeledObject.MetaData): Single&lt;LabeledObject&lt;T&gt;&gt; {        var single = Single.just(LabeledObject(ConcurrentHashMap(), item, metaData = metaData))        for (op in extractors) {            single = single.flatMap { op.extractLabel(it).toSingleDefault(it) }        }        return single    }    class Builder&lt;T : Any&gt;(val logger: Logger) {        private val list = LinkedList&lt;LabelExtractor&lt;T&gt;&gt;()        private var sink: EventSink? = null        fun sinkTo(sink: EventSink): Builder&lt;T&gt; {            this.sink = sink            return this        }        fun addOp(extractor: LabelExtractor&lt;T&gt;): Builder&lt;T&gt; {            list.addLast(extractor)            return this        }        fun build(): LabelPipeline&lt;T&gt; {            return LabelPipeline(list, logger, sink)        }    }    override fun close() {        for (op in extractors) {            op.flushSession(providedSink)            op.close()        }    }}\n\n\n\ninterface LabelExtractor&lt;T : Any&gt; : Closeable, EventSource {    /**     * Extractor执行计算     */    fun extractLabel(item: LabeledObject&lt;T&gt;): Completable    /**     * 告知计算已结束，Extractor应将尚未上报的事件进行上报     */    fun flushSession(sink: EventSink?) {}    fun labelKey(sourceType: String, category: String, vendor: String, vendorKey: String): String {        return \"$sourceType:$category:$vendor:$vendorKey\"    }}\n\n\n\n视频导出通过ByteBuffer导出成MP4格式视频\ncom/danale/edge/ui/flow/VideoFlowViewModel.kt\nfun attachPlayer(        surface: Surface,        clipDri: String,        clipDataSource: ByteBufferVideoSource? = null,        positionResponder: ClipPositionResponder? = null    ) {        logger.d(            TAG,            \"attachPlayer, clipDri=${Fuzzy.interval(clipDri)}, data=${clipDataSource?.hashCode()}\"        )        positionResponder?.let {            // 弱引用保存播放进度的响应体            weakPositionResponder = WeakReference(it)        }        loadPlayerExecutor.submit {            detachPlayerSync()            if (player == null) {                logger.i(TAG, \"attachPlayer, instantiate\")                player = IjkPlayerProvider.provideIjkPlayerDefaultConfig()            }            player?.apply {                try {                    setSurface(surface)                    setOnPreparedListener {                      // 开始播放视频                    }                    setOnErrorListener { mediaPlayer, errArg1, errArg2 -&gt;                        // 错误被处理                    }                    setOnCompletionListener {                        // 视频播放完毕                    }                } catch (e: Exception) {                    logger.e(TAG, \"attachPlayer, null mp\", e)                }            }            if (clipDataSource != null) {                logger.i(TAG, \"attachPlayer, use exist data\")                try {                    // 播放已有视频                } catch (e: Exception) {}            } else {                logger.i(TAG, \"attachPlayer, load clip ${Fuzzy.interval(clipDri)}\")                val latch = CountDownLatch(1)                dataSubscription = sdk.getBlobWithDri(clipDri)                    .subscribeOn(Schedulers.io())                    .subscribeBy(                        onSuccess = {                            logger.i(TAG, \"attachPlayer, blob ok\")                            try {                                val data = ByteBufferVideoSource()                                data.load(it)                                preparePlayer(data)                                /***保存bytebuffer****/                               saveBytebuffer(it, clipDri.split(\"clip_\")[1])                            } catch (e: Exception) {}                            latch.countDown()                        },                        onError = {}                    )                latch.await()            }        }    }\n\n其中data.load(it)是获取视频来源，it是ByteBuffer格式，通过保it为MP4格式可以实现视频的导出，不同的视频通过clipDri加以区分\n// 获取存储路径private fun getPath(): String {    val result = (Environment.getExternalStorageDirectory().toString()            + File.separator + Environment.DIRECTORY_DCIM            + File.separator + \"Camera\" + File.separator)    val file = File(result)    if (!file.exists()) {        file.mkdir()    }    return result + File.separator}// 保存ByteBufferprivate fun saveBytebuffer(byteBuffer: ByteBuffer, fileName: String){    logger.d(TAG, \"attachPlayer, save bytebuffer\")    val file = File(getPath()+ fileName + \".mp4\")    logger.d(TAG, \"attachPlayer, file=$file\")    if(!file.exists()){        file.createNewFile();    }    val os: OutputStream = FileOutputStream(file,true)    os.write(byteBuffer.array())    os.flush()    os.close()}\n\nclipDri是String格式，但直接将其存为文件名会有非法字符，[D*]dri:data_worm:kv:blob:grid/827f8b9cfbb780df63f56fe6e7bef03c:clip_f00b3dd5c79411edaa64d54fbc172c8c\n通过截取拿到clip_后的部分组成文件名\n视频导入图片导入通过ffmpeg将mp4视频文件分割成jpg图片文件\nffmpeg -i  test.mp4 -r 10 -f image2 %05d.jpg\n\n\n-i : 指定输入文件\n-r : 帧数 10\n-f : 指定格式化的格式为image2\nimage2后面跟着的是文件名\n%5d：以为5位数按正序编号\n\n将图片放入到app的文件夹中，由于手机的安全性，放入其他文件夹会读不到文件/sdcard/Android/data/com.alcidae.edgeapp/files\n通过context.getExternalFilesDir(null)获取到文件夹路径，存入每个图片的名称\nprivate fun getPics(): MutableList&lt;String&gt; {    logger.d(TAG, \"start getPics, ${context.getExternalFilesDir(null)}\")    val fileNames: MutableList&lt;String&gt; = mutableListOf()    val fileTree = File(\"${context.getExternalFilesDir(null)}/test\").walk()    fileTree.maxDepth(1) //需遍历的目录层次为1，即无须检查子目录        .filter {            it.isFile        } //只挑选文件，不处理文件夹        .filter {            it.extension in listOf(\"jpg\")        }//选择扩展名为jpg的文件        .forEach {            fileNames.add(it.absolutePath)        }//循环 处理符合条件的文件    return fileNames}\n\n通过循环读取图片，并将图片转成bitmap输入到pipeline\n@SuppressLint(\"CheckResult\")private fun pipelineFromPic(files: MutableList&lt;String&gt;) {    for (i in  0 until files.size){        val file = File(files[i])        //readBytes读取字节数组形式的文件内容        val bytes = file.readBytes()        //decodeByteArray从字节数组解析图片        val currBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)        val metaData =            LabeledObject.MetaData(dataTimestamp = i.toLong())  // 新建data 承载源数据        videoPipeline.process(currBitmap, metaData)            // 扁平化            .flatMap {                val elapsedNano = it.getElapsedMillis()                logger.d(TAG, \"for, inferenceTime = $elapsedNano\")                it.obj.recycle()  // 释放与此位图关联的本机对象，并清除对像素数据的引用                return@flatMap Single.just(it)  // 转换为发出该对象的Single            }            .subscribeBy(                onSuccess = {                    logger.d(TAG, \"for, onSuccess, i=$i, labeledObject = $it\")                },                onError = {                    logger.d(TAG, \"for, onError, i=$i, throwable = $it\")                    close()                },            )    }    videoPipeline.close()}\n\nval files = getPics()pipelineFromPic(files)\n\n\n\n音频导入通过ffmpeg工具将mp4文件转成pcm文件\nffmpeg -i test.mp4 test.mp3ffmpeg -i test.mp3 -ar 48000 -ac 2 -f s16le test.pcm\n\n@SuppressLint(\"CheckResult\")fun videoPipeline() {    val file = File(\"${context.getExternalFilesDir(null)}/test/test.pcm\")    val bytes = file.readBytes()    val metaData = LabeledObject.MetaData(dataTimestamp = 1.toLong())    logger.d(TAG, \"bytes.size= ${bytes.size}\")    val step = 640  // 每次读取的大小    val num = floor((bytes.size / step).toDouble())  // 循环次数    for (i in 0 until num.toInt()) {        val byte = bytes.slice(i..i + step)  // 截取pcm        val shorts = ShortArray(byte.size / 2) {            (byte[it * 2].toUByte().toInt() + (byte[(it * 2) + 1].toInt() shl 8)).toShort()        }  // 转换成shortArray        Maybe.fromSingle(audioPipeline.process(shorts, metaData)            .flatMap {                val elapsedNano = it.getElapsedMillis()                logger.d(TAG, \"audioPipe, inferenceTime = $elapsedNano\")                return@flatMap Single.just(it)            }).subscribeBy(            onSuccess = {                logger.d(TAG, \"for, onSuccess, labeledObject = $it\")            },            onError = {                logger.d(TAG, \"for, onError, throwable = $it\")                close()            },        )    }    audioPipeline.close()}\n\n","categories":["有在认真上班"],"tags":["写了什么新功能"]},{"title":"设置页面","url":"/blog/2023/03/15/%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2/","content":"概述内容设置页面动态生成\n需求\n展示的内容完全通过配置确定\n设置项的值目前有开关，数值和枚举三种情况，预留未来扩展\n 设置项的描述支持标题和副标题，预留未来扩展\n支持跳转二级页面\n支持分组\n\n预计周期1～2周\n过程实现数据获取接口配置接口类型新建一个operation文件用来定义接口的入参和出参\ncom/danale/edge/usersdk/operation/GetDeviceSettingListOp.kt\npackage com.danale.edge.usersdk.operationimport com.danale.edge.foundation.log.Loggerimport com.danale.edge.usersdk.jni.BaseJsonOperationimport com.danale.edge.usersdk.jni.BaseResponseimport com.google.gson.Gsonimport com.google.gson.annotations.SerializedNameclass GetDeviceSettingListOp (val param: Param, logger: Logger, gson: Gson) :    BaseJsonOperation&lt;GetDeviceSettingListOp.Response&gt;(logger, gson) {    // 这里是回调    override fun unmarshallSerializedResponse(jsonOutput: String?): Response {        val response = Response()        val array = gson.fromJson(jsonOutput, Array&lt;ResultBean&gt;::class.java)        response.list = array        return response    }    // 传入数据    override fun performOperation(context: CallbackContext) {        context.nativeResponseCallback(0, 0, \"\", mockList)  // 在这里使用mock数据    }    // 入参    class Param(        @SerializedName(\"device_id\") val deviceId: String,        @SerializedName(\"device_type\") val deviceType: Int,    )      // 出参    class Response : BaseResponse() {      // 返回一个Array        var list: Array&lt;ResultBean&gt;? = null        override fun toString(): String {            return \"Response(list=${list?.contentToString()})\"        }    }    class ResultBean {        @SerializedName(\"name\")        val name: String? = null        @SerializedName(\"items\")        val items: Array&lt;Item&gt;? = null        override fun toString(): String {            return \"ResultBean(name=$name, items=$items)\"        }    }    class Item {        @SerializedName(\"id\")        val id: String? = null        @SerializedName(\"type\")        val type: String? = null        @SerializedName(\"subId\")        val subId: String? = null        override fun toString(): String {            return \"Item(id=$id, type=$type, subId=$subId)\"        }    }}\n\nmock数据如下\n[    {        \"name\": \"text_basic_setting\",        \"items\": [            {                \"id\": \"text_device_name\",                \"type\": \"String\"            },            {                \"id\": \"text_device_info\",                \"type\": \"Fragment\"            },            {                \"id\": \"text_service_net\",                \"type\": \"Fragment\"            },            {                \"id\": \"Synchronize\",                \"subId\": \"SynchronizeDescribe\",                \"type\": \"Boolean\"            }        ]    },    {        \"name\": \"text_device_setting\",        \"items\": [            {                \"id\": \"text_device_flip\",                \"subId\": \"flipDescribe\",                \"type\": \"Boolean\"            }        ]    }]\n\n\n\n接口定义和实现在userSdk中定义接口路径\ncom/danale/edge/usersdk/usecase/UserSdkUseCase.kt\n/** * 获取设备设置列表 */fun getDeviceSettingList(    id: String,    type: Int): Single&lt;GetDeviceSettingListOp.Response&gt;\n\n在userSdkImpl中实现\ncom/danale/edge/usersdk/usecase/UserSdkUseCaseImpl.kt\noverride fun getDeviceSettingList(    id: String,    type: Int): Single&lt;GetDeviceSettingListOp.Response&gt; {    return GetDeviceSettingListOp(GetDeviceSettingListOp.Param(id, type), logger, gsonInst)}\n\n\n\n数据获取在viewModel中获取数据\n/** * 获取设备设置列表 */private fun loadSettingList() {  viewModelScope.launch {    val list = withContext(Dispatchers.IO) {      try {        deviceId32?.let {            logger.d(TAG, \"loadSettingList, getDeviceSettingList\")            sdk.getDeviceSettingList(it, deviceTypeCode).await()        }      } catch (e: Exception) {        toastError(e)        null      }    }  }}\n\n\n\nwhen (title) {    \"text_basic_setting\" -&gt; {        add(Section().apply {            setHeader(SectionHeaderItem(getString(R.string.text_setting_basic)))            when (item.id) {                \"text_setting_basic_device_name\" -&gt; {                    add(nameItem)                }                \"text_setting_basic_device_info\" -&gt; {                    add(                        StatusItem(                            getString(R.string.text_setting_basic_device_info),                            actionId = ACTION_NAV_ID_DEVICE_INFO                        )                    )                }                \"text_setting_basic_device_network\" -&gt; {                    add(                        StatusItem(                            getString(R.string.text_setting_basic_device_network),                            actionId = ACTION_NAV_ID_DEVICE_NETWORK                        )                    )                }                \"Synchronize\" -&gt; {                    add(                        SwitchItem(                            getString(R.string.text_allow_metered_sync),                            subTitle = getString(R.string.text_allow_metered_sync_tip),                            backgroundResId = R.drawable.bg_round_bottom,                            showSeparator = false,                            loadBlock = { item -&gt;                                val useMeteredData =                                    preference.getAllowMeteredDataCompute()                                logger.d(TAG, \"load, useMeteredData, $useMeteredData\")                                (item as? SwitchItem)?.isChecked = useMeteredData                            },                            checkedListener = { button, isChecked -&gt;                                logger.d(                                    TAG,                                    \"cellular sync change, $isChecked, $button\"                                )                                preference.setAllowMeteredDataCompute(isChecked)                            }                        ))                }            }        })    }    \"text_setting_device\" -&gt; {        add(Section().apply {            setHeader(SectionHeaderItem(getString(R.string.text_setting_device)))            when (item.id) {                \"text_setting_ipc_flip_state\" -&gt; {                    add(                        SwitchItem(                            getString(R.string.text_setting_ipc_flip_state),                            subTitle = getString(R.string.text_setting_ipc_flip_state_tip),                            backgroundResId = R.drawable.bg_round_bottom,                            showSeparator = false,                            loadBlock = { item -&gt;                                logger.d(TAG, \"loadBlock, flip, $item\")                                val state = deviceThingInfo?.run {                                    performOnIOWithDefault(null) {                                        sdk.getDeviceFlipStatusWithCache(this).await()                                    }                                } ?: DpFlipState.NORMAL                                logger.d(TAG, \"loadBlock, flip state, $state\")                                (item as? SwitchItem)?.isChecked =                                    (state == DpFlipState.UP_SIDE_DOWN)                            },                            checkedListener = { button, isChecked -&gt;                                logger.d(                                    TAG,                                    \"checkedListener, flip, $isChecked, $button\"                                )                                val state =                                    if (isChecked) DpFlipState.UP_SIDE_DOWN else DpFlipState.NORMAL                                viewModelScope.launch {                                    performOnIOWithDefault(null) {                                        deviceThingInfo?.let {                                            sdk.setDeviceFlipStatusWithCache(it, state)                                                .await()                                        }                                    }                                }                            }                        ))                }            }        })    }}\n\n\ncom/danale/edge/appbiz/ApplicationBusinessModule.kt\n@Module@InstallIn(SingletonComponent::class)interface ApplicationBusinessModule {    @Binds    @Singleton    fun bindSettingItemFactory(impl: SettingItemFactory): SettingItemRepository}\n\n\n\ncom/danale/edge/ui/devicecontrol/setting/SettingItemRepository.kt\npackage com.danale.edge.ui.devicecontrol.settinginterface SettingItemRepository {}\n\n\n\ncom/danale/edge/ui/devicecontrol/setting/DeviceSettingListViewModel.kt\n// 设置项map@Injectlateinit var settingItem: SettingItemFactory\n\n\n\ncom/danale/edge/ui/devicecontrol/setting/SettingItemFactory.kt\nclass SettingItemFactory @Inject constructor(    private val preference: AppPrefRepository) :SettingItemRepository {    fun syncAction(item: BaseSettingItem&lt;RecyclerGroupieItemSwitchBinding&gt;): Boolean {        val useMeteredData = preference.getAllowMeteredDataCompute()        (item as? SwitchItem)?.isChecked = useMeteredData        return useMeteredData    }}\n\n","categories":["有在认真上班"],"tags":["写了什么新功能"]},{"title":"20230907","url":"/blog/2023/09/07/9-07/","content":"Bug√ release包出现反序列化失败崩溃崩溃日志java.lang.RuntimeException: Parcelable encountered IOException writing serializable object (name = d7.b)\tat android.os.Parcel.writeSerializable(Parcel.java:1843)\tat android.os.Parcel.writeValue(Parcel.java:1790)\tat android.os.Parcel.writeArrayMapInternal(Parcel.java:932)\tat android.os.BaseBundle.writeToParcelInner(BaseBundle.java:1588)\tat android.os.Bundle.writeToParcel(Bundle.java:1253)\tat android.os.Parcel.writeBundle(Parcel.java:1001)\tat android.content.Intent.writeToParcel(Intent.java:10858)\tat android.app.IActivityTaskManager$Stub$Proxy.startActivity(IActivityTaskManager.java:3880)\tat android.app.Instrumentation.execStartActivity(Instrumentation.java:1738)\tat android.app.Activity.startActivityForResult(Activity.java:5412)\tat androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.java:2)\tat android.app.Activity.startActivityForResult(Activity.java:5337)\tat androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.java:1)\tat android.app.Activity.startActivity(Activity.java:5819)\tat android.app.Activity.startActivity(Activity.java:5787)\tat c4.y.a(BaseNavigation.kt:8)\tat c4.b$a.l(BaseActivity.kt:3)\tat c4.b.O(Unknown Source:2)\tat c4.w$b.l(BaseFragment.kt:2)\tat c4.a.d(R8$$SyntheticClass:5)\tat d4.a.d(R8$$SyntheticClass:8)\tat androidx.lifecycle.LiveData.b(LiveData.java:6)\tat androidx.lifecycle.LiveData.c(LiveData.java:8)\tat androidx.lifecycle.x.l(MutableLiveData.java:4)\tat d4.b.l(SingleLiveEvent.kt:2)\tat androidx.lifecycle.LiveData$a.run(LiveData.java:5)\tat android.os.Handler.handleCallback(Handler.java:900)\tat android.os.Handler.dispatchMessage(Handler.java:103)\tat android.os.Looper.loop(Looper.java:219)\tat android.app.ActivityThread.main(ActivityThread.java:8673)\tat java.lang.reflect.Method.invoke(Native Method)\tat com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513)\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1109)Caused by: java.io.NotSerializableException: com.google.gson.internal.s$a\tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1240)\tat java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1604)\tat java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1565)\tat java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1488)\tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1234)\tat java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1604)\tat java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1565)\tat java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1488)\tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1234)\tat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:354)\tat android.os.Parcel.writeSerializable(Parcel.java:1838)\t... 32 more\n\n根据mapping.txt文件解出错误类是Clip\n出现在从收藏页面分享给app内好友，从首页分享不会出错，问题在于release包的代码混淆导致了解析出错，暂不清楚具体原因\npackage com.danale.edge.usersdk.type.clipimport com.danale.edge.foundation.privacy.Fuzzyimport com.danale.edge.usersdk.type.LabelBeanimport com.google.gson.annotations.SerializedName/** * UserSDK生成的Clip，用于表示一段多媒体资源 * @param timeMillisGenerated 该[Clip]被生成的时间 * @param type 该[Clip]的类型，有两种类型，分别是\"本机原始数据（本机生成的）Clip\"（type = 1）和\"非本机原始数据（非本机生成的）Clip\"（type = 2） * @param clip_id */open class Clip(    @SerializedName(\"timestamp_ms\") val timeMillisGenerated: Long,    @SerializedName(\"play_mode\") val playMode: Int,    @SerializedName(\"type\") val type: Int,    @SerializedName(\"clip_id\") var clipID: String,    @SerializedName(\"ori_data\") var originalDataList: List&lt;OriginalData&gt;? = null,    @SerializedName(\"non_ori_data_paths\") var nonOriginalData: Map&lt;String, String&gt;? = null,    @SerializedName(\"custom_data\") var custom_data: String? = null,    @SerializedName(\"label_item\") var labelInfoList: List&lt;LabelBean&gt;? = null,    @SerializedName(\"favorite\") var favorite: Int) : java.io.Serializable, Comparable&lt;Any?&gt; {    companion object {        const val CLIP_TYPE_ORIGINAL_DATA = 1       // 原始数据Clip        const val CLIP_TYPE_NON_ORIGINAL_DATA = 2   // 非原始数据Clip        const val CLIP_PLAY_MODE_LOCAL = 0          // 本地播放        const val CLIP_PLAY_MODE_REMOTE_DEVICE = 1  // 设备端播放，需要拉取        fun getStartTimeMillis(clip: Clip) = clip.originalDataList?.get(0)?.startTimeMillis ?: 0        fun getEndTimeMillis(clip: Clip) = clip.originalDataList?.get(0)?.endTimeMillis ?: 0        fun getOriDataListString(clip: Clip): String? {            return clip.originalDataList?.joinToString(separator = \"-\") {                \"${it.deviceID}-${it.startTimeMillis}-${it.endTimeMillis}\"            }        }    }    var isFromSelf: Boolean = false    override fun equals(other: Any?): Boolean {        if (other !is Clip) return false        if (timeMillisGenerated != other.timeMillisGenerated) return false        if (type != other.type) return false        if (clipID != other.clipID) return false        if (originalDataList != other.originalDataList) return false        if (nonOriginalData != other.nonOriginalData) return false        if (custom_data != other.custom_data) return false        return labelInfoList == other.labelInfoList    }    override fun toString(): String {        return \"timeMillisGenerated=$timeMillisGenerated),\" +                \"type=$type),\" +                \"clipID=${Fuzzy.interval(clipID)}, \" +                \"originalDataList=$originalDataList, \" +                \"nonOriginalData=$nonOriginalData, \" +                \"custom_data=$custom_data, \" +                \"labelInfoList=$labelInfoList, \" +                \"favorite=$favorite\"    }    override fun hashCode(): Int {        var result = timeMillisGenerated?.hashCode() ?: 0        result = 31 * result + (type?.hashCode() ?: 0)        result = 31 * result + (clipID?.hashCode() ?: 0)        result = 31 * result + (originalDataList?.hashCode() ?: 0)        result = 31 * result + (nonOriginalData?.hashCode() ?: 0)        result = 31 * result + (custom_data?.hashCode() ?: 0)        result = 31 * result + labelInfoList.hashCode()        return result    }    override fun compareTo(other: Any?): Int {        if (other !is Clip) return 1        return (clipID ?: \"\").compareTo(other.clipID ?: \"\")    }    data class OriginalData(        @SerializedName(\"device_id\") var deviceID: String,        @SerializedName(\"start_time_ms\") var startTimeMillis: Long,        @SerializedName(\"end_time_ms\") var endTimeMillis: Long,    ) : java.io.Serializable    class NonOriginalData {        companion object {            const val KEY_MP4_PATH = \"mp4_path\"            const val KEY_FIRST_FRAME_IMAGE_PATH = \"first_frame_image_path\"        }    }}fun Clip.setIsFromSelf(flag: Boolean) {    isFromSelf = flag}fun Clip.getIsFromSelf(): Boolean {    return isFromSelf}\n\nrecord通过GSON进行序列化\n2023.9.7  \n\n69b6c8a70389bc0e6b1c013e6a5bd7d6667d9111 \n\n15db304d83582b514a82dde17fc6665d4543ab27\n\n\nval clipString = gson.toJson(clip)pv.store(EXTRA_SEND_TO_CONTACT_CLIP, clipString)val clipString = viewModel.pvStoreRepository.read(EXTRA_SEND_TO_CONTACT_CLIP) ?: \"\"val clip = viewModel.gson.fromJson(clipString, Clip::class.java)\n\n\n\n接收IOS大拿分享的视频出现内部错误偶现\n错误日志2023-09-05 18:53:41.230 D/VideoFlowActivity: [main-1] handleShareEvent: accept=[true], eventId=[1276c0f077ef4756ad7a4073ab259134]2023-09-05 18:53:41.230 I/UserSdkNative: [DefaultDispatcher-worker-1-7942] nativeShareHandleEvent, ref=0x2af62023-09-05 18:53:41.230 I/UserSdkNative: [Thread-9285-18158] [module/contact] HandleClipShareApply(1276c0f077ef4756ad7a4073ab259134, 1)2023-09-05 18:53:41.233 E/UserSdkNative: [Thread-9285-18158] [module/contact] HandleClipShareApply(1276c0f077ef4756ad7a4073ab259134, 1) failed, hmi.HandleClipShareApply failed, syncClipNonOriData failed, zip.OpenReader(/storage/emulated/0/Android/data/com.danale.edge/files/user_local/volume/id_6ul5lak8wzfe/temp/hmi/clips/zip/601964a6e3d84514a554263d37f01abc) failed, zip: not a valid zip file2023-09-05 18:53:41.233 D/UserSdkNative: [Thread-9285-18158] app_dip_fe_usr_sdk_general_json_callback, ctx 0x2af62023-09-05 18:53:41.234 W/VideoFlowActivity: [DefaultDispatcher-worker-1-7942] handleShareEvent error, c7.b: Api request failed with code:-2; biz:0(hmi.HandleClipShareApply failed, syncClipNonOriData failed, zip.OpenReader(/storage/emulated/0/Android/data/com.danale.edge/files/user_local/volume/id_6ul5lak8wzfe/temp/hmi/clips/zip/601964a6e3d84514a554263d37f01abc) failed, zip: not a valid zip file)2023-09-05 18:53:41.234 E/VideoFlowActivity: [DefaultDispatcher-worker-1-7942] toastError exceptionc7.b: Api request failed with code:-2; biz:0(hmi.HandleClipShareApply failed, syncClipNonOriData failed, zip.OpenReader(/storage/emulated/0/Android/data/com.danale.edge/files/user_local/volume/id_6ul5lak8wzfe/temp/hmi/clips/zip/601964a6e3d84514a554263d37f01abc) failed, zip: not a valid zip file)\tat com.danale.edge.usersdk.jni.BaseJsonOperation$CallbackContext.nativeResponseCallback(BaseJsonOperation.kt:10)\n\n主要错误：\nApi request failed with code:-2; biz:0(hmi.HandleClipShareApply failed, syncClipNonOriData failed, zip.OpenReader(/storage/emulated/0/Android/data/com.danale.edge/files/user_local/volume/id_6ul5lak8wzfe/temp/hmi/clips/zip/601964a6e3d84514a554263d37f01abc) failed, zip: not a valid zip file)\n\n\n\n√远端同步过来的视频不能收藏搜索页会出现\n目前逻辑是远端的视频不能播放，所以在首页会过滤掉远端的视频只保留本地视频，即\n/** * 过滤首页远端视频资源，同时对远端视频发起拉取 */@SuppressLint(\"CheckResult\")private suspend fun filterPlayList(list: List&lt;Clip&gt;): List&lt;Clip&gt; {    val localList = list.filter { it.playMode == CLIP_PLAY_MODE_LOCAL }.toMutableList()    val remoteList = list.filter { it.playMode == CLIP_PLAY_MODE_REMOTE_DEVICE }.toMutableList()    // 当cursor未拉取到数据或拉取数量不足时会重复拉取，直到cursor为空或数量满足    while (localList.isEmpty() || localList.size &lt; LOAD_VIDEO_MIN) {        if (nextCursor.isEmpty()) {            logger.e(TAG, \"no newList\")            break        }        val newList = getVideoList(nextCursor)        newList.filter { it.playMode == CLIP_PLAY_MODE_LOCAL }            .forEach { localList.add(it) }        newList.filter { it.playMode == CLIP_PLAY_MODE_REMOTE_DEVICE }            .forEach { remoteList.add(it) }    }    logger.d(TAG, \"localList size=${localList.size}, remoteList size=${remoteList.size}\")    // 远端拉取    getRemoteList(remoteList)    return localList}\n\n在搜索页中的视频做同样的操作，过滤掉远端视频\n目前搜索页通过sdk分别获取人脸和tag的数据放到展示，存在问题是点进某个人脸或标签得到的视频是远端的导致没法播放，所以收藏也会失败\nrecord现在的代码中getFaceList是拉取sdk人脸库中的数据，也就是所有的人脸，包括别的摄像机拍摄出的人脸，属于远端数据，所以会出现有的视频无法观看\nprivate fun loadPersonIdentities() {  viewModelScope.launch {      val newList = performOnIOWithDefault(emptyList()) {          // 获取所有人脸          val faceList = sdkFaceDatabase.blockingGetSdkFaceList()          // 获取本机所有标签          val labels = sdk.getAllLabel().await()          // 提取出标签中的 faceUserId 部分          val filteredLabels = labels.map { it.substringAfter(Label.IDENTITY_PREFIX.key) }          // 过滤出本机中的人脸          faceList.filter { filteredLabels.contains(it.faceUserId) }      }      searchPersonAdapter.replaceALl(newList)      _personCount.value = searchPersonAdapter.getFrontFaceList().size  }}\n\n首先拿到本机中的所有label，这个label是本机的数据\nval labels = sdk.getAllLabel().await()\n\n再根据Id进行筛选，根据label中的Label.IDENTITY_PREFIX.key部分取faceList和labels中的交集人脸列表得到newList，将newList作为最终数据添加到adapter中\n// 提取出人脸标签中的 faceUserId 部分val filteredLabels = labels.map { it.substringAfter(Label.IDENTITY_PREFIX.key) }// 过滤出本机中的人脸val newList = faceList.filter { filteredLabels.contains(it.faceUserId) }\n\n最终代码\nprivate fun loadPersonIdentities() {  viewModelScope.launch {      // 获取所有人脸摘要      val faceSummaryList = performOnIOWithDefault(emptyList()) {          getAllFaceSummary()      }      // 获取所有人脸      val faceList = withContext(Dispatchers.IO) {          sdk.getFaceList(faceSummaryList)      }    /******************修改部分*****************/      val labels = sdk.getAllLabel().await()      // 提取出人脸标签中的 faceUserId 部分      val filteredLabels = labels.map { it.substringAfter(Label.IDENTITY_PREFIX.key) }      // 过滤出本机中的人脸      val newList = faceList.filter { filteredLabels.contains(it.faceUserId) }      searchPersonAdapter.faceList.clear()      searchPersonAdapter.faceList.addAll(newList)    /******************修改部分*****************/          // fixme: SuppressLint 后续换SortedList      searchPersonAdapter.notifyDataSetChanged()      _personCount.value = searchPersonAdapter.faceList.size  }}\n\n保存MP4视频出现文件不存在crash2023-09-05 22:33:13.945 I/FileUtil: [DefaultDispatcher-worker-8-1724] [S]saveVideo2023-09-05 22:33:13.948 E/FileUtil: [DefaultDispatcher-worker-8-1724] [S]clip type is not original data2023-09-05 22:33:14.077 E/BaseApplication: [DefaultDispatcher-worker-8-1724] uncaughtException, thread = Thread[DefaultDispatcher-worker-8,5,main]java.io.FileNotFoundException:/storage/emulated/0/Android/data/com.danale.edge/files/user_local/volume/id_6xur6vx43a5c/temp/hmi/clips/nod/42adff7f955c4d56af4c48f5cf5e7ac1/mp4_path: open failed: ENOENT (No such file or directory)\tat libcore.io.IoBridge.open(IoBridge.java:574)\tat java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:160)\tat k6.b.c(FileUtil.kt:18)\tat com.danale.edge.ui.flow.VideoFlowViewModel.V(VideoFlowViewModel.kt:17)\tat u6.c$a.d(DownloadDialog.kt:4)\tat qh.a.o(ContinuationImpl.kt:3)\tat ei.q0.run(DispatchedTask.kt:18)\tat ji.g.run(LimitedDispatcher.kt:2)\tat li.j.run(Tasks.kt:1)\tat li.a$a.run(CoroutineScheduler.kt:14)\tSuppressed: ei.o0: [b2{Cancelling}@b8522be, Dispatchers.IO]Caused by: android.system.ErrnoException: open failed: ENOENT (No such file or directory)\tat libcore.io.Linux.open(Native Method)\tat libcore.io.ForwardingOs.open(ForwardingOs.java:563)\tat libcore.io.BlockGuardOs.open(BlockGuardOs.java:274)\tat libcore.io.ForwardingOs.open(ForwardingOs.java:563)\tat android.app.ActivityThread$AndroidOs.open(ActivityThread.java:8274)\tat libcore.io.IoBridge.open(IoBridge.java:560)\t... 9 more\n\n(No such file or directory)\n问题出现在：\nif (clip.type != Clip.CLIP_TYPE_ORIGINAL_DATA) {  /**   * FIXME: 目前不支持编辑已经是MP4的文件, 暂时全部返回原视频   *  收藏页 -&gt; 添加拍摄者水印   *  非本人拍摄(app内分享) -&gt; 添加拍摄者水印   *  已经有水印(识别视频) -&gt; 直接保存原视频   * */  logger.e(TAG, \"clip type is not original data\")  val nonOriMP4Path = clip.nonOriginalData?.get(Clip.NonOriginalData.KEY_MP4_PATH)  return if (nonOriMP4Path != null) {      try {          File(nonOriMP4Path)      }catch (e: Exception){          null      }  } else {      null  }}\n\nFile(nonOriMP4Path)中的路径不存在，可能原因是\n​    如果path存在缓存文件夹中，那么存在手动清除缓存导致文件夹不存在，(需要重新修改需求？)\n​    如果存在file文件夹中，前面的逻辑可能存在问题\n√ 日志导出方式修改改为双击应用版本整个item导出日志\nfun showLog(view: View) {  val currentTime = System.currentTimeMillis()  val clickDelay = currentTime - lastClickTime  if (clickDelay &lt; 500) {      clickCount++  } else {      clickCount = 1  }  lastClickTime = currentTime  if (clickCount &gt;= 2) {      logVisible.set(true)  }}\n\n\n\n√ 我的页面，部分视频没有展示收藏缩略图之前的获取方式会导致list不全\nval list = sdk.getFavoriteList(\"\").await().list\n\n改成当指针不为空的时候持续调用接口\nval list = performOnIOWithDefault(emptyList()) {    val resultClipsList = ArrayList&lt;Clip&gt;()    var currentCursor = \"\"    do {        val resp = sdk.getFavoriteList(currentCursor).await()        resp.nextCursor.run {            logger.d(TAG, \"getFavoriteList, nextCursor = $this\")            currentCursor = this            nextCursor = this        }        resp.list?.let { resultClipsList.addAll(it) }    } while (currentCursor.isNotEmpty())    resultClipsList}\n\n\n\nNew√ 收藏缩略图修改存在拉伸，修改type为裁剪\nandroid:scaleType=\"centerCrop\"\n&lt;androidx.appcompat.widget.LinearLayoutCompat    android:id=\"@+id/group_favorite\"    android:layout_width=\"wrap_content\"    android:layout_height=\"wrap_content\"    android:layout_gravity=\"end\"    android:orientation=\"horizontal\"    android:layout_marginEnd=\"24dp\"    app:layout_constraintTop_toTopOf=\"parent\"    app:layout_constraintEnd_toStartOf=\"@+id/arrow\"&gt;    &lt;androidx.appcompat.widget.AppCompatImageView        android:id=\"@+id/favorite_1\"        android:layout_width=\"64dp\"        android:layout_height=\"64dp\"        android:scaleType=\"centerCrop\"        android:layout_marginStart=\"4dp\" /&gt;    &lt;androidx.appcompat.widget.AppCompatImageView        android:id=\"@+id/favorite_2\"        android:layout_width=\"64dp\"        android:layout_height=\"64dp\"        android:scaleType=\"centerCrop\"        android:layout_marginStart=\"4dp\" /&gt;    &lt;androidx.appcompat.widget.AppCompatImageView        android:id=\"@+id/favorite_3\"        android:layout_width=\"64dp\"        android:layout_height=\"64dp\"        android:scaleType=\"centerCrop\"        android:layout_marginStart=\"4dp\" /&gt;&lt;/androidx.appcompat.widget.LinearLayoutCompat&gt;\n","categories":["有在认真上班"],"tags":["2023 9月记录"]},{"title":"人脸匹配好友列表","url":"/blog/2023/04/07/%E4%BA%BA%E8%84%B8%E5%8C%B9%E9%85%8D%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8/","content":"概述内容人脸匹配好友列表\n需求\n算法检测出的人脸配到当前的好友列表\n如果有好友的人脸显示好友名称\n\n过程设置备注页Activity新建一个activity文件用于展示当前点击的头像\nlayout/activity_user_face.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".ui.userface.UserFaceActivity\"&gt;    &lt;androidx.fragment.app.FragmentContainerView        android:id=\"@+id/fragment_user_name\"        android:name=\"com.danale.edge.ui.userface.UserFaceFragment\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        tools:layout=\"@layout/fragment_user_face\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\n\n\ncom/danale/edge/ui/userface/UserFaceActivity.kt\npackage com.danale.edge.ui.userfaceimport android.annotation.SuppressLintimport android.app.Activityimport android.content.Intentimport android.os.Bundleimport androidx.activity.viewModelsimport com.danale.edge.Rimport com.danale.edge.base.BaseActivityimport com.danale.edge.base.BaseNavigation.Constantsimport com.danale.edge.ui.userface.UserFaceViewModel.Companion.REQUEST_CODEimport com.danale.edge.usersdk.usecase.UserSdkUseCaseimport com.google.gson.Gsonimport dagger.hilt.android.AndroidEntryPointimport io.reactivex.rxjava3.kotlin.subscribeByimport io.reactivex.rxjava3.schedulers.Schedulersimport java.nio.charset.StandardCharsetsimport javax.inject.Inject@AndroidEntryPointclass UserFaceActivity : BaseActivity() {    private val viewModel: UserFaceViewModel by viewModels()    @Inject    lateinit var userSdk: UserSdkUseCase    @Inject    lateinit var gson: Gson    // 当前点击的人脸下标     private var mainPosition: Int? = 0    companion object {        const val CURRENT_USER_FACE = \"CURRENT_USER_FACE\"    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_user_face)    }    @SuppressLint(\"CheckResult\")    override fun onResume() {        super.onResume()        // 拿到当前用户下标        mainPosition = intent?.getIntExtra(Constants.EXTRA_SEARCH_MAIN_POSITION, 0)        viewModel.loadSearchHistoryItems(mainPosition)        /**         * 加载人脸的好友数据         * */        userSdk.loadAssistData(CURRENT_USER_FACE)            .subscribeOn(Schedulers.io())            .subscribeBy(onSuccess = {                val cb = StandardCharsets.UTF_8.decode(it)                val json = cb.toString()                logger.d(                    TAG,                    \"decode, buffer=${it?.remaining()}, json=${json}\"                )                val mapData = gson.fromJson(json, MutableMap::class.java)                val name = mapData[mainPosition.toString()]                viewModel.setName(name as String?)            }, onError = {                logger.w(TAG, \"load assist, buffer, error\", it)            })    }  \t/**  \t* 这里用到了startActivityForResult，用于页面带参数返回，参考  \t* https://blog.csdn.net/weixin_41008021/article/details/90346700  \t*/    @Deprecated(\"Deprecated in Java\")    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {        super.onActivityResult(requestCode, resultCode, data)        when (requestCode) {            REQUEST_CODE -&gt; {                if (resultCode == Activity.RESULT_OK) {                    if (data != null) {                        viewModel.setName(data.getStringExtra(Constants.EXTRA_SEARCH_MAIN_POSITION))                    }                }            }        }    }}\n\n\n\nFragmentlayout/fragment_user_face.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"viewModel\"            type=\"com.danale.edge.ui.userface.UserFaceViewModel\" /&gt;        &lt;import type=\"android.view.View\" /&gt;    &lt;/data&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:background=\"@mipmap/art_bg_flow\"        tools:context=\".ui.userface.UserFaceActivity\"&gt;        &lt;com.danale.edge.ui.common.view.TopSafeAreaGuideLine            android:id=\"@+id/safe_area_top_guide\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"            app:layout_constraintGuide_begin=\"24dp\"            tools:ignore=\"MissingConstraints\" /&gt;        &lt;include            android:id=\"@+id/component_title_bar\"            layout=\"@layout/component_title_bar\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            app:layout_constraintTop_toBottomOf=\"@id/safe_area_top_guide\" /&gt;        &lt;androidx.appcompat.widget.LinearLayoutCompat            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:orientation=\"vertical\"            tools:ignore=\"MissingConstraints\"&gt;            &lt;androidx.recyclerview.widget.RecyclerView                android:id=\"@+id/recycler_persons\"                android:layout_width=\"match_parent\"                android:layout_height=\"wrap_content\"                android:adapter=\"@{viewModel.searchPersonAdapter}\"                tools:background=\"#AFBC9D\" /&gt;            &lt;TextView                android:id=\"@+id/tv_user_nickname\"                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:layout_marginTop=\"24dp\"                android:text=\"@{viewModel.currentUserName}\"                android:textColor=\"@color/app_std_text_white\"                android:textSize=\"18sp\"                tools:text=\"Alcidae Username\" /&gt;            &lt;TextView                android:layout_width=\"wrap_content\"                android:layout_height=\"wrap_content\"                android:background=\"@drawable/bg_rounded_button\"                android:backgroundTint=\"@color/app_primary\"                android:onClick=\"@{viewModel::onClickSetFriend}\"                android:paddingHorizontal=\"16dp\"                android:paddingVertical=\"8dp\"                android:text=\"@string/text_replay\"                android:textColor=\"@color/app_std_text_primary_inverse\"                app:layout_constraintBottom_toBottomOf=\"parent\"                app:layout_constraintEnd_toEndOf=\"parent\"                app:layout_constraintStart_toStartOf=\"parent\"                app:layout_constraintTop_toTopOf=\"parent\" /&gt;        &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\n\n\ncom/danale/edge/ui/userface/UserFaceFragment.kt\npackage com.danale.edge.ui.userfaceimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.databinding.DataBindingUtilimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.getimport androidx.recyclerview.widget.LinearLayoutManagerimport com.danale.edge.Rimport com.danale.edge.base.BaseFragmentimport com.danale.edge.databinding.FragmentUserFaceBindingclass UserFaceFragment : BaseFragment() {    private lateinit var viewModel: UserFaceViewModel    lateinit var binding: FragmentUserFaceBinding    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        viewModel = ViewModelProvider(requireActivity()).get()        binding =            DataBindingUtil.inflate(inflater, R.layout.fragment_user_face, container, false)        binding.viewModel = this.viewModel        binding.lifecycleOwner = viewLifecycleOwner        binding.recyclerPersons.apply {            layoutManager =                LinearLayoutManager(requireContext(), LinearLayoutManager.HORIZONTAL, false)        }        viewModel = ViewModelProvider(requireActivity()).get()        binding.viewModel = this.viewModel        return binding.root    }    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {        observeNavigation(viewModel)    }    override fun onResume() {        super.onResume()        setStatusBarDarkText(false, inverseOnNightMode = false)    }}\n\n\nViewModelpackage com.danale.edge.ui.userfaceimport android.annotation.SuppressLintimport android.app.Applicationimport android.content.Intentimport android.view.Viewimport androidx.databinding.ObservableFieldimport androidx.lifecycle.viewModelScopeimport com.danale.edge.base.BaseNavigationimport com.danale.edge.base.BaseViewModelimport com.danale.edge.intelligence.IntelligenceRepositoryimport com.danale.edge.ui.common.adapter.PersonAdapterimport com.danale.edge.ui.common.adapter.ThumbnailAdapterimport com.danale.edge.ui.common.callback.RecyclerItemOnClickimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.withContextimport javax.inject.Inject@HiltViewModelclass UserFaceViewModel @Inject constructor(application: Application) : BaseViewModel(application),    RecyclerItemOnClick&lt;ThumbnailAdapter.ThumbnailViewHolder&gt; {    @Inject    lateinit var ai: IntelligenceRepository    // 当前用户名称    var currentUserName = ObservableField(\"\")    private var mainPosition = 0    // 用于给activity传参的标志    companion object {        const val REQUEST_CODE = 1    }    /**     * 当前页面的头像     * */    val searchPersonAdapter =        PersonAdapter(itemOnClick = object : RecyclerItemOnClick&lt;PersonAdapter.PersonViewHolder&gt; {            override fun onClickItem(viewHolder: PersonAdapter.PersonViewHolder) {                logger.d(TAG, \"onClickPerson=$viewHolder\")            }        })    /**     * 加载当前点击的人脸图片     * */    @SuppressLint(\"NotifyDataSetChanged\")    fun loadSearchHistoryItems(position: Int?) {        if (position != null) {            mainPosition = position        }        viewModelScope.launch {            val faceUsers = withContext(Dispatchers.IO) {                ai.getFaceUserList()            }            searchPersonAdapter.list.clear()            searchPersonAdapter.list.add(faceUsers[position!!])            // fixme: SuppressLint 后续换SortedList            searchPersonAdapter.notifyDataSetChanged()        }    }    /**     * 设置名称     * */    @SuppressLint(\"NotifyDataSetChanged\")    fun setName(name: String?) {        logger.d(TAG, \"setName, name = $name\")        currentUserName.set(name)    }    /**     * 点击设置名称     * */    @Suppress(\"UNUSED_PARAMETER\") // View.OnClickListener    fun onClickSetFriend(view: View) {        val intent = Intent().apply {            putExtra(                BaseNavigation.Constants.EXTRA_SEARCH_MAIN_POSITION,                mainPosition,            )        }      \t// BaseNavigation封装的方法        navigationRequiredEvent.postValue(            BaseNavigation(                BaseNavigation.Route.USER_FACE_FRIEND_LIST,                intent,                true,                REQUEST_CODE            )        )    }    override fun onClickItem(viewHolder: ThumbnailAdapter.ThumbnailViewHolder) {        logger.d(TAG, \"viewHolder=$viewHolder\")    }}\n\n这里的跳转用到了onActivityResult， 使用的是BaseNavigation封装后的方法，第三个参数为是否开启startForResult，第四个参数是标志\n封装的方法如下：\nfun launch(fromActivity: Activity, intent: Intent? = null) {  val finalIntent = Intent(fromActivity, route.activityClass)  paramIntent?.let { finalIntent.putExtras(it) }  intent?.let { finalIntent.putExtras(it) }  if (startForResult) {      fromActivity.startActivityForResult(finalIntent, requestCode, requestBundle)  } else {      fromActivity.startActivity(finalIntent)  }}\n\n每次跳转都会走到launch函数中\n好友列表页Activitycom/danale/edge/ui/userface/UserFaceFriendListActivity.kt\npackage com.danale.edge.ui.userfaceimport android.annotation.SuppressLintimport android.app.Activityimport android.content.Intentimport android.os.Bundleimport androidx.activity.viewModelsimport com.danale.edge.Rimport com.danale.edge.base.BaseActivityimport com.danale.edge.base.BaseNavigationimport dagger.hilt.android.AndroidEntryPointimport kotlinx.coroutines.*@AndroidEntryPointclass UserFaceFriendListActivity : BaseActivity() {    private val viewModel: UserFaceFriendListViewModel by viewModels()    @SuppressLint(\"SuspiciousIndentation\")    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_user_face_friend_list)        // 第一次跳转过来的时候拿到点击的下标        val mainPosition =            intent?.getIntExtra(BaseNavigation.Constants.EXTRA_SEARCH_MAIN_POSITION, 0)        if (mainPosition != null) {            viewModel.setPosition(mainPosition)        }        MainScope().launch {            viewModel.loadPlatformContactList()        }    }    override fun onResume() {        super.onResume()        viewModel.navigationRequiredEvent.observe(this) {            it?.launch(this)        }        observeNavigation(viewModel)        // 非首次跳转        // 监听viewModel的liveData        viewModel.liveData.observe(this) {            val intent = Intent().apply {                putExtra(                    BaseNavigation.Constants.EXTRA_SEARCH_MAIN_POSITION,                    it,                )            }            // 返回上一页面            setResult(Activity.RESULT_OK, intent)            finish()        }    }}\n\n跳转的逻辑写在了ViewModel中，无法调用Acitvity中的setResult和finish方法，因此通过一个liveData传值通知Activity进行相关操作，ViewModel与Activity/Fragments通讯的正确姿势 - 掘金 (juejin.cn)\nlayout/activity_user_face_friend_list.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".ui.userface.UserFaceFriendListActivity\"&gt;    &lt;androidx.fragment.app.FragmentContainerView        android:id=\"@+id/fragment_user_name\"        android:name=\"com.danale.edge.ui.userface.UserFaceFriendListFragment\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        tools:layout=\"@layout/fragment_user_face_friend_list\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\n\n\nFragmentlayout/fragment_user_face_friend_list.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"viewModel\"            type=\"com.danale.edge.ui.userface.UserFaceFriendListViewModel\" /&gt;    &lt;/data&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:background=\"@color/app_std_background_gray\"&gt;        &lt;com.danale.edge.ui.common.view.TopSafeAreaGuideLine            android:id=\"@+id/safe_area_top_guide\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"            app:layout_constraintGuide_begin=\"24dp\"            tools:ignore=\"MissingConstraints\" /&gt;        &lt;include            android:id=\"@+id/component_title_bar\"            layout=\"@layout/component_title_bar\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            app:layout_constraintTop_toBottomOf=\"@id/safe_area_top_guide\" /&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=\"@+id/recycler_view\"            android:layout_width=\"match_parent\"            android:layout_height=\"0dp\"            android:adapter=\"@{viewModel.starUserAdapter}\"            android:clipToPadding=\"false\"            android:overScrollMode=\"never\"            android:paddingBottom=\"24dp\"            app:layout_constraintBottom_toBottomOf=\"parent\"            app:layout_constraintTop_toBottomOf=\"@id/component_title_bar\" /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\n\n\ncom/danale/edge/ui/userface/UserFaceFriendListFragment.kt\npackage com.danale.edge.ui.userfaceimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.databinding.DataBindingUtilimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.getimport androidx.recyclerview.widget.LinearLayoutManagerimport com.danale.edge.Rimport com.danale.edge.base.BaseFragmentimport com.danale.edge.databinding.FragmentUserFaceFriendListBindingclass UserFaceFriendListFragment : BaseFragment() {    private lateinit var binding: FragmentUserFaceFriendListBinding    private lateinit var viewModel: UserFaceFriendListViewModel    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        binding = DataBindingUtil.inflate(            inflater,            R.layout.fragment_user_face_friend_list,            container,            false        )        binding.lifecycleOwner = viewLifecycleOwner        binding.componentTitleBar.apply {            leftIconRes = R.mipmap.ic_back_black            responder = this@UserFaceFriendListFragment        }        binding.recyclerView.apply {            layoutManager =                LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)            itemAnimator?.changeDuration = 0L // 关闭变化动画防止刷新内容时闪烁        }        viewModel = ViewModelProvider(requireActivity()).get()        binding.viewModel = this.viewModel        return binding.root    }    override fun onResume() {        super.onResume()        setStatusBarDarkText(true)    }}\n\n\nViewModelcom/danale/edge/ui/userface/UserFaceFriendListViewModel.kt\npackage com.danale.edge.ui.userfaceimport android.annotation.SuppressLintimport android.app.Applicationimport androidx.lifecycle.MutableLiveDataimport com.danale.edge.base.BaseViewModelimport com.danale.edge.ui.common.adapter.ThumbnailAdapterimport com.danale.edge.ui.common.callback.RecyclerItemOnClickimport com.danale.edge.ui.common.groupie.UserFaceFriendItemimport com.danale.edge.usersdk.usecase.UserSdkUseCaseimport com.google.gson.Gsonimport com.xwray.groupie.GroupieAdapterimport com.xwray.groupie.Sectionimport dagger.hilt.android.lifecycle.HiltViewModelimport io.reactivex.rxjava3.kotlin.subscribeByimport io.reactivex.rxjava3.schedulers.Schedulersimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.rx3.awaitLastimport kotlinx.coroutines.rx3.awaitSingleOrNullimport kotlinx.coroutines.withContextimport org.json.JSONExceptionimport org.json.JSONObjectimport java.nio.charset.StandardCharsetsimport javax.inject.Inject@HiltViewModelclass UserFaceFriendListViewModel @Inject constructor(application: Application) :    BaseViewModel(application),    RecyclerItemOnClick&lt;ThumbnailAdapter.ThumbnailViewHolder&gt; {    // 用于加载页面的Adapter    val starUserAdapter = GroupieAdapter()    // 最终列表中的数据格式    data class UserFaceFriend(        var name: String?,        var url: String?,        var nameId: String?    )    // 最终求交集的星标列表    private var userFaceFriendList = ArrayList&lt;UserFaceFriend&gt;()    private var mainPosition = 0    @Inject    lateinit var userSdk: UserSdkUseCase    @Inject    lateinit var gson: Gson    val liveData = MutableLiveData&lt;String&gt;()    companion object {        const val CURRENT_USER_FACE = \"CURRENT_USER_FACE\"    }    /**     * 拿到对应position     * */    fun setPosition(position: Int) {        mainPosition = position    }    /**     * 加载好友列表     */    suspend fun loadPlatformContactList(refresh: Boolean = false) {        try {            // 获取的好友列表            withContext(Dispatchers.IO) {                sdk.getFriendsList(forceReFetch = refresh).awaitLast().map {                    // 用户名                    val displayName = if (it.remarkName?.isNotEmpty() == true) {                        it.remarkName                    } else {                        it.likeName                    }                    // 用户头像                    val url = withContext(Dispatchers.IO) {                        it.userName?.let { it1 -&gt;                            sdk.getPhotoUrlByPlatformUserName(it1).awaitSingleOrNull()                        }                    }                    // 添加数据                    userFaceFriendList.add(                        UserFaceFriend(                            displayName,                            url,                            it.userName                        )                    )                }            }            // 构建列表            buildSettingItems()        } catch (e: Exception) {            toastError(e)        }    }    /**     * 构建好友列表     * */    @SuppressLint(\"CheckResult\")    private fun buildSettingItems() {        logger.d(TAG, \"buildSettingItems starFriendList=${userFaceFriendList}\")        starUserAdapter.apply {            add(Section().apply {                for ((i, item) in userFaceFriendList.withIndex()) {                    item.url?.let { url -&gt;                        item.name?.let { name -&gt;                            UserFaceFriendItem(                                avatar = url,  // 头像链接                                name = name,  // 用户名                                clickListener = {                                    // 加载数据                                    userSdk.loadAssistData(CURRENT_USER_FACE)                                        .subscribeOn(Schedulers.io())                                        .subscribeBy(onSuccess = {                                            val cb = StandardCharsets.UTF_8.decode(it)                                            val json = cb.toString()                                            val mapJson = if (json == \"null\") {                                                val data = mapOf(\"$mainPosition\" to name)                                                gson.toJson(data)                                            } else {                                                val mapData = getMap(json)                                                // 添加数据                                                mapData?.set(mainPosition.toString(), name)                                                gson.toJson(mapData)                                            }                                            //更新数据                                            userSdk.storeAssistData(                                                CURRENT_USER_FACE, mapJson.toByteArray(StandardCharsets.UTF_8)                                            )                                                .subscribeOn(Schedulers.io())                                                .subscribeBy(onSuccess = {                                                    logger.d(TAG, \"updateFaceUserList, buffer, success\")                                                }, onError = { e -&gt;                                                    logger.e(TAG, \"updateFaceUserList, buffer, error\",e)                                                })                                            // 传递给liveData通知activity跳转                                            liveData.postValue(mainPosition.toString())                                        }, onError = {                                            logger.w(TAG, \"load assist, buffer, error\", it)                                        })                                }                            )                        }                    }?.let { add(it) }                }            })        }    }    private fun getMap(jsonString: String?): HashMap&lt;String, Any&gt;? {        val jsonObject: JSONObject        try {            jsonObject = jsonString?.let { JSONObject(it) }!!            val keyIter: Iterator&lt;String&gt; = jsonObject.keys()            var key: String            var value: Any            val valueMap = HashMap&lt;String, Any&gt;()            while (keyIter.hasNext()) {                key = keyIter.next()                value = jsonObject[key] as Any                valueMap[key] = value            }            return valueMap        } catch (e: JSONException) {            e.printStackTrace()        }        return null    }    override fun onClickItem(viewHolder: ThumbnailAdapter.ThumbnailViewHolder) {        logger.d(TAG, \"viewHolder=$viewHolder\")    }}\n\n\n结果\n","categories":["有在认真上班"],"tags":["写了什么新功能"]},{"title":"星标用户","url":"/blog/2023/03/28/%E6%98%9F%E6%A0%87%E7%94%A8%E6%88%B7/","content":"概述内容实现星标用户的页面\n需求\n加载星标用户列表：starUserLoad\n加载好友列表: com.danale.edge.usersdk.usecase.UserSdkUseCase#getFriendsList\n使用好友的用户名获取昵称：com.danale.edge.usersdk.usecase.UserSdkUseCaseImpl#getUserLikeNameByPlatformUserName\n使用好友的用户名获取头像：com.danale.edge.usersdk.usecase.UserSdkUseCaseImpl#getPhotoUrlByPlatformUserName\n\n\n每个好友后面有一个ratio，false-&gt;true触发starUserStore， true-&gt;false -&gt; starUserDelete\n\n过程定义接口Op存用户com/danale/edge/usersdk/operation/StarUserStoreOp.kt\npackage com.danale.edge.usersdk.operationimport com.danale.edge.foundation.log.Loggerimport com.danale.edge.usersdk.jni.BaseJsonOperationimport com.danale.edge.usersdk.jni.BaseResponseimport com.danale.edge.usersdk.jni.UserSdkWrapperimport com.google.gson.Gsonimport com.google.gson.annotations.SerializedNameclass StarUserStoreOp(val param: Param, logger: Logger, gson: Gson) :    BaseJsonOperation&lt;BaseResponse&gt;(logger, gson) {    override fun unmarshallSerializedResponse(jsonOutput: String?): BaseResponse {        return BaseResponse()    }    override fun performOperation(context: CallbackContext) {        UserSdkWrapper.nativeStoreStarUserList(context, gson.toJson(param))    }    class Param(        @SerializedName(\"star_user_list\") val starUserList: List&lt;StarUserListInfo&gt;    )    class StarUserListInfo(        @SerializedName(\"device_id\") val deviceId: String? = null,        @SerializedName(\"user_name\") val userName: String? = null    ) {        override fun toString(): String {            return \"StarUserStoreOp(deviceId=$deviceId, name=$userName)\"        }    }}\n\n在performOperation中定义了接口UserSdkWrapper.nativeStoreStarUserList\nexternal fun nativeStoreStarUserList(    context: NativeResponseCallback,    paramJsonString: String)\n\n在这里调用c++的实现\nextern \"C\"JNIEXPORT void JNICALLJava_com_danale_edge_usersdk_jni_UserSdkWrapper_nativeStoreStarUserList(JNIEnv *env, jobject thiz,                                                                        jobject context,                                                                        jstring param_json_string) {    jboolean isCopy = JNI_TRUE;    const char *param_json_string_chars = env-&gt;GetStringUTFChars(param_json_string,                                                                 &amp;isCopy);    jobject ctx_ref = env-&gt;NewGlobalRef(context);    APP_LOG_I(\"nativeStoreStarUserList, ref=%p\", ctx_ref);    dip_pub_user_store_star_user(ctx_ref,                                 const_cast&lt;char *&gt;(param_json_string_chars),                                 app_dip_fe_usr_sdk_general_json_callback);    env-&gt;ReleaseStringUTFChars(param_json_string, param_json_string_chars);}\n\ndip_pub_user_store_star_user是最终接口的名称\n/* * @brief 存储星标用户 * @param [in]args_json.star_user_list 星标用户信息数组 * @param [in]args_json.user_list.device_id 设备id * @param [in]args_json.user_list.user_name 用户名 example: 请求参数示例 {\"star_user_list\":[{\t\"device_id\": \"xxxxxxxxxxxxxx\",\t\"user_name\": \"xxxxxxxxxxxxxx\",}] } 成功返回0，失败返回error code*/extern void dip_pub_user_store_star_user(dip_fe_usr_sdk_ctx ctx, char* args_json, dip_fe_usr_sdk_json_callback callback);\n\n取用户com/danale/edge/usersdk/operation/StarUserLoadOp.kt\npackage com.danale.edge.usersdk.operationimport com.danale.edge.foundation.log.Loggerimport com.danale.edge.usersdk.jni.BaseJsonOperationimport com.danale.edge.usersdk.jni.BaseResponseimport com.danale.edge.usersdk.jni.UserSdkWrapperimport com.google.gson.Gsonimport com.google.gson.annotations.SerializedNameclass StarUserLoadOp(val param: Param, logger: Logger, gson: Gson) :    BaseJsonOperation&lt;StarUserLoadOp.Response&gt;(logger, gson) {    override fun unmarshallSerializedResponse(jsonOutput: String?): Response {        return gson.fromJson(jsonOutput, Response::class.java) ?: Response(emptyList())    }    override fun performOperation(context: CallbackContext) {        UserSdkWrapper.nativeGetStarUserList(context, gson.toJson(param))    }    class Param(        @SerializedName(\"device_id\") var id: String    )    class Response(toList: List&lt;StarUserInfo&gt;) : BaseResponse() {        @SerializedName(\"star_user_list\")        var deviceIdList: List&lt;StarUserInfo&gt;? = null        override fun toString(): String {            return \"StarUserLoadOp(deviceIdList=${deviceIdList})\"        }    }    class StarUserInfo {        @SerializedName(\"user_name\")        val userName: String = \"\"        override fun toString(): String {            return \"StarUserLoadOp(userName=$userName)\"        }    }}\n\nexternal fun nativeGetStarUserList(    context: NativeResponseCallback,    paramJsonString: String)\n\nextern \"C\"JNIEXPORT void JNICALLJava_com_danale_edge_usersdk_jni_UserSdkWrapper_nativeGetStarUserList(JNIEnv *env, jobject thiz,                                                                      jobject context,                                                                      jstring param_json_string) {    jboolean isCopy = JNI_TRUE;    const char *param_json_string_chars = env-&gt;GetStringUTFChars(param_json_string,                                                                 &amp;isCopy);    jobject ctx_ref = env-&gt;NewGlobalRef(context);    APP_LOG_I(\"nativeGetStarUserList, ref=%p\", ctx_ref);    dip_pub_user_load_star_user_list(ctx_ref,                                     const_cast&lt;char *&gt;(param_json_string_chars),                                     app_dip_fe_usr_sdk_general_json_callback);    env-&gt;ReleaseStringUTFChars(param_json_string, param_json_string_chars);}\n\n/* * @brief 存储星标用户 * @param [in]args_json.device_id                 设备id * @param [out]args_json.star_user_list           星标用户列表 * @param [out]args_json.star_user_list.user_name 用户名 example: 请求参数示例 {\t\"device_id\": \"xxxxxxxxx\", } 返回参数示例 {\t\"star_user_list\":    [        {\"user_name\" : \"xxxxx\"},        {\"user_name\" : \"xxxxx\"}    ] }*/extern void dip_pub_user_load_star_user_list(dip_fe_usr_sdk_ctx ctx, char *args_json,                                             dip_fe_usr_sdk_json_callback callback);\n\n删用户com/danale/edge/usersdk/operation/StarUserDeleteOp.kt\npackage com.danale.edge.usersdk.operationimport com.danale.edge.foundation.log.Loggerimport com.danale.edge.usersdk.jni.BaseJsonOperationimport com.danale.edge.usersdk.jni.BaseResponseimport com.danale.edge.usersdk.jni.UserSdkWrapperimport com.google.gson.Gsonimport com.google.gson.annotations.SerializedNameclass StarUserDeleteOp(val param: Param, logger: Logger, gson: Gson) :    BaseJsonOperation&lt;BaseResponse&gt;(logger, gson) {    override fun unmarshallSerializedResponse(jsonOutput: String?): BaseResponse {        return BaseResponse()    }    override fun performOperation(context: CallbackContext) {        UserSdkWrapper.nativeDeleteStarUserList(context, gson.toJson(param))    }    class Param(        @SerializedName(\"star_user_list\") val starUserList: List&lt;StarUserListInfo&gt;    )    class StarUserListInfo(        @SerializedName(\"device_id\") val deviceId: String? = null,        @SerializedName(\"user_name\") val userName: String? = null    ) {        override fun toString(): String {            return \"StarUserStoreOp(deviceId=$deviceId, name=$userName)\"        }    }}\n\nexternal fun nativeDeleteStarUserList(    context: NativeResponseCallback,    paramJsonString: String)\n\nextern \"C\"JNIEXPORT void JNICALLJava_com_danale_edge_usersdk_jni_UserSdkWrapper_nativeDeleteStarUserList(JNIEnv *env, jobject thiz,                                                                         jobject context,                                                                         jstring param_json_string) {    jboolean isCopy = JNI_TRUE;    const char *param_json_string_chars = env-&gt;GetStringUTFChars(param_json_string,                                                                 &amp;isCopy);    jobject ctx_ref = env-&gt;NewGlobalRef(context);    APP_LOG_I(\"nativeDeleteStarUserList, ref=%p\", ctx_ref);    dip_pub_user_delete_star_users(ctx_ref,                                   const_cast&lt;char *&gt;(param_json_string_chars),                                   app_dip_fe_usr_sdk_general_json_callback);    env-&gt;ReleaseStringUTFChars(param_json_string, param_json_string_chars);}\n\n/* * @brief 批量删除指定星标用户集合 * @param [in]args_json.device_id                 设备id * @param [in]args_json.star_user_list           需要删除的星标用户列表 * @param [in]args_json.star_user_list.user_name 星标用户名 example: 请求参数示例 {\"star_user_list\":[{\t\"device_id\": \"xxxxxxxxxxxxxx\",\t\"user_name\": \"xxxxxxxxxxxxxx\",}] } 删除成功返回0，失败返回相应错误码*/extern void dip_pub_user_delete_star_users(dip_fe_usr_sdk_ctx ctx, char *args_json,                                           dip_fe_usr_sdk_json_callback callback);\n\n\n\n定义接口sdk通过sdk绑定到Op上\ncom/danale/edge/usersdk/usecase/UserSdkUseCase.kt\n/** * 获取星标好友列表 */fun getStarUserList(    id: String,): Single&lt;StarUserLoadOp.Response&gt;/** * 添加星标好友 * */fun storeStarUser(    deviceId: String,    userName: String): Completable/** * 删除星标好友 * */fun deleteStarUser(    deviceId: String,    userName: String): Completable\n\ncom/danale/edge/usersdk/usecase/UserSdkUseCaseImpl.kt\noverride fun getStarUserList(    id: String): Single&lt;StarUserLoadOp.Response&gt; {    return StarUserLoadOp(StarUserLoadOp.Param(id), logger, gsonInst)}override fun storeStarUser(deviceId: String, userName: String): Completable {    return StarUserStoreOp(        StarUserStoreOp.Param(            listOf(                StarUserStoreOp.StarUserListInfo(                    deviceId,                    userName                )            )        ), logger, gsonInst    ).flatMapCompletable {        Completable.complete()    }}override fun deleteStarUser(deviceId: String, userName: String): Completable {    return StarUserDeleteOp(        StarUserDeleteOp.Param(            listOf(                StarUserDeleteOp.StarUserListInfo(                    deviceId,                    userName                )            )        ), logger, gsonInst    ).flatMapCompletable {        Completable.complete()    }}\n\n\n\n业务逻辑实现Fragment定义用于展示用户列表的Fragment\ncom/danale/edge/ui/devicecontrol/common/StarUserFragment.kt\npackage com.danale.edge.ui.devicecontrol.commonimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.databinding.DataBindingUtilimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.getimport androidx.recyclerview.widget.LinearLayoutManagerimport com.danale.edge.Rimport com.danale.edge.base.BaseFragmentimport com.danale.edge.databinding.FragmentStarUserBindingclass StarUserFragment : BaseFragment() {    private lateinit var binding: FragmentStarUserBinding    private lateinit var viewModel: StarUserViewModel    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        binding = DataBindingUtil.inflate(inflater, R.layout.fragment_star_user, container, false)        binding.lifecycleOwner = viewLifecycleOwner        binding.componentTitleBar.apply {            leftIconRes = R.mipmap.ic_back_black            title = getString(R.string.text_star_user)            responder = this@StarUserFragment        }        binding.recyclerView.apply {            layoutManager =                LinearLayoutManager(requireContext(), LinearLayoutManager.VERTICAL, false)            itemAnimator?.changeDuration = 0L // 关闭变化动画防止刷新内容时闪烁        }        viewModel = ViewModelProvider(requireActivity()).get()        binding.viewModel = this.viewModel        return binding.root    }    override fun onResume() {        super.onResume()        setStatusBarDarkText(true)    }}\n\n\n\n定义对应的Fragment绑定\nlayout/fragment_star_user.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"viewModel\"            type=\"com.danale.edge.ui.devicecontrol.common.StarUserViewModel\" /&gt;    &lt;/data&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:background=\"@color/app_std_background_gray\"&gt;        &lt;com.danale.edge.ui.common.view.TopSafeAreaGuideLine            android:id=\"@+id/safe_area_top_guide\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"            app:layout_constraintGuide_begin=\"24dp\"            tools:ignore=\"MissingConstraints\" /&gt;        &lt;include            android:id=\"@+id/component_title_bar\"            layout=\"@layout/component_title_bar\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            app:layout_constraintTop_toBottomOf=\"@id/safe_area_top_guide\" /&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=\"@+id/recycler_view\"            android:layout_width=\"match_parent\"            android:layout_height=\"0dp\"            android:adapter=\"@{viewModel.starUserAdapter}\"            android:clipToPadding=\"false\"            android:overScrollMode=\"never\"            android:paddingBottom=\"24dp\"            app:layout_constraintBottom_toBottomOf=\"parent\"            app:layout_constraintTop_toBottomOf=\"@id/component_title_bar\" /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\n\n\nViewModelpackage com.danale.edge.ui.devicecontrol.commonimport android.app.Applicationimport androidx.lifecycle.viewModelScopeimport com.danale.edge.base.BaseViewModelimport com.danale.edge.foundation.privacy.Fuzzyimport com.danale.edge.ui.common.callback.RecyclerItemOnClickimport com.danale.edge.ui.common.groupie.StarUserItemimport com.danale.edge.ui.common.recycler.RecyclerListViewHolderimport com.danale.edge.usersdk.operation.StarUserLoadOpimport com.xwray.groupie.GroupieAdapterimport com.xwray.groupie.Sectionimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.launchimport kotlinx.coroutines.rx3.awaitimport kotlinx.coroutines.rx3.awaitLastimport kotlinx.coroutines.rx3.awaitSingleOrNullimport kotlinx.coroutines.withContextimport javax.inject.Inject@HiltViewModelclass StarUserViewModel @Inject constructor(application: Application) :    BaseViewModel(application), RecyclerItemOnClick&lt;RecyclerListViewHolder&gt; {    // 用于加载页面的Adapter    val starUserAdapter = GroupieAdapter()    // 获取的星标列表    private var starUserList: StarUserLoadOp.Response? = null    // 用一个map存储获得的星标列表中的用户id    private var starUserMap: MutableMap&lt;String, Boolean&gt; = mutableMapOf()    // 最终列表中的数据格式    data class StarFriend(        var name: String?,        var url: String?,        var isStar: Boolean,        var nameId: String?    )    // 最终求交集的星标列表    private var starFriendList = ArrayList&lt;StarFriend&gt;()    // 设备id    var deviceId32: String? = null        set(value) {            logger.d(TAG, \"setDeviceId=${Fuzzy.interval(value)}\")            field = value            viewModelScope.launch {                // 获取的好友列表                loadPlatformContactList()            }        }    /**     * 获取星标好友列表     */    private suspend fun loadStarFriendList() {        starUserList = withContext(Dispatchers.IO) {            try {                deviceId32?.let {                    sdk.getStarUserList(it).await()                }            } catch (e: Exception) {                toastError(e)                null            }        }        logger.d(TAG, \"loadStarFriendList, starUserList=$starUserList\")    }    /**     * 加载好友列表     */    private suspend fun loadPlatformContactList(refresh: Boolean = false) {        try {            // 获取的星标列表            loadStarFriendList()            val nonNullList = starUserList?.deviceIdList ?: emptyList()            if (nonNullList.isNotEmpty()) nonNullList.forEach {                starUserMap[it.userName] = true            }            // 获取的好友列表            withContext(Dispatchers.IO) {                sdk.getFriendsList(forceReFetch = refresh).awaitLast()?.map { it -&gt;                    // 用户名                    val displayName = if (it.remarkName?.isNotEmpty() == true) {                        it.remarkName                    } else {                        it.likeName                    }                    // 用户头像                    val url = withContext(Dispatchers.IO) {                        it.userName?.let { it1 -&gt;                            sdk.getPhotoUrlByPlatformUserName(it1).awaitSingleOrNull()                        }                    }                    // 添加数据                    starFriendList.add(                        StarFriend(                            displayName,                            url,                            starUserMap[it.userName] !== null,                            it.userName                        )                    )                }            }            logger.i(TAG, \"loadPlatformContactList, starFriendList= $starFriendList\")            // 构建列表            buildSettingItems()        } catch (e: Exception) {            toastError(e)        }    }    // 构建列表    private fun buildSettingItems() {        starUserAdapter.apply {            add(Section().apply {                for ((i, item) in starFriendList.withIndex()) {                    item.url?.let { url -&gt;                        item.name?.let { name -&gt;                            StarUserItem(                                list = starFriendList,  // 传入最新的列表获得isStar属性                                avatar = url,  // 头像链接                                name = name,  // 用户名                                clickListener = { _ -&gt;                                    if (!item.isStar) {                                        // 存                                        viewModelScope.launch {                                            withContext(Dispatchers.IO) {                                                try {                                                    deviceId32?.let { did -&gt;                                                        item.nameId?.let { nameId -&gt;                                                            sdk.storeStarUser(                                                                did,                                                                nameId                                                            ).await()                                                        }                                                    }                                                    // 更新列表                                                    starFriendList[i] =                                                        StarFriend(name, url, true, item.nameId)                                                } catch (e: Exception) {                                                    logger.d(TAG, \"error, $e\")                                                }                                            }                                          \t// 通知Adapter刷新数据                                            starUserAdapter.notifyItemChanged(i, 0)                                        }                                     } else {                                        // 删                                        viewModelScope.launch {                                            withContext(Dispatchers.IO) {                                                try {                                                    deviceId32?.let { did -&gt;                                                        item.nameId?.let { nameId -&gt;                                                            sdk.deleteStarUser(                                                                did,                                                                nameId                                                            ).await()                                                        }                                                    }                                                    starFriendList[i] =                                                        StarFriend(name, url, false, item.nameId)                                                } catch (e: Exception) {                                                    logger.d(TAG, \"error, $e\")                                                }                                            }                                            starUserAdapter.notifyItemChanged(i, 0)                                        }                                    }                                }                            )                        }                    }?.let { StarUserItem -&gt;                        add(                            StarUserItem                        )                    }                }            })        }    }    override fun onClickItem(viewHolder: RecyclerListViewHolder) {        logger.d(TAG, \"onClickItem, viewHolder=$viewHolder\")    }}\n\n\n\nStarUserItem定义一个用于展示用户的组件\ncom/danale/edge/ui/common/groupie/StarUserItem.kt\npackage com.danale.edge.ui.common.groupieimport android.annotation.SuppressLintimport android.view.Viewimport androidx.databinding.DataBindingUtilimport coil.loadimport coil.transform.RoundedCornersTransformationimport com.danale.edge.Rimport com.danale.edge.databinding.RecyclerGroupieItemStarUserBindingimport com.danale.edge.ui.devicecontrol.common.StarUserViewModelimport com.xwray.groupie.viewbinding.BindableItemclass StarUserItem(    var list: ArrayList&lt;StarUserViewModel.StarFriend&gt; = ArrayList(),    var avatar: String,    var name: String = \"\",    val clickListener: ((View) -&gt; Unit)? = null) : BindableItem&lt;RecyclerGroupieItemStarUserBinding&gt;() {    @SuppressLint(\"ClickableViewAccessibility\")    override fun bind(viewBinding: RecyclerGroupieItemStarUserBinding, position: Int) {        viewBinding.let {            it.ivUserAvatar.load(this.avatar) {                placeholder(R.mipmap.clipart_default_avatar_round)                error(R.mipmap.clipart_default_avatar_round)                transformations(RoundedCornersTransformation(36f))            }            it.name = this.name            it.switchAccessory.isSelected = this.list[position].isStar            it.switchAccessory.setOnClickListener(clickListener)        }    }    override fun getLayout(): Int {        return R.layout.recycler_groupie_item_star_user    }    override fun initializeViewBinding(view: View): RecyclerGroupieItemStarUserBinding {        return DataBindingUtil.bind(view) ?: throw IllegalStateException(\"unable to bind view\")    }}\n\n\n每次调用会进入bind方法，所以传入一个List列表，根据列表中的isStar属性判断是否是星标用户\n头像不能直接显示，要通过load方法加载图片\nplaceholder：默认图片\nerror： 出现错误时的图片\ntransformations： 图片相关操作，这里定义了图片圆角\n\n\ngetLayout用于绑定到页面布局文件\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"name\"            type=\"String\" /&gt;        &lt;variable            name=\"isStar\"            type=\"Boolean\" /&gt;        &lt;import type=\"android.view.View\" /&gt;    &lt;/data&gt;    &lt;androidx.coordinatorlayout.widget.CoordinatorLayout        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        tools:background=\"@color/black\"&gt;        &lt;androidx.constraintlayout.widget.ConstraintLayout            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:layout_marginHorizontal=\"16dp\"            android:minHeight=\"56dp\"            tools:background=\"@color/white\"&gt;            &lt;androidx.appcompat.widget.LinearLayoutCompat                android:id=\"@+id/group_title\"                android:layout_width=\"0dp\"                android:layout_height=\"wrap_content\"                android:layout_marginVertical=\"15dp\"                android:layout_marginStart=\"16dp\"                android:orientation=\"horizontal\"                app:layout_constraintBottom_toBottomOf=\"parent\"                app:layout_constraintEnd_toStartOf=\"@id/switch_accessory\"                app:layout_constraintStart_toStartOf=\"parent\"                app:layout_constraintTop_toTopOf=\"parent\"&gt;                &lt;androidx.appcompat.widget.AppCompatImageView                    android:id=\"@+id/iv_user_avatar\"                    android:layout_width=\"45dp\"                    android:layout_height=\"45dp\"                    android:focusable=\"true\" /&gt;                &lt;androidx.appcompat.widget.AppCompatTextView                    android:layout_width=\"match_parent\"                    android:layout_height=\"wrap_content\"                    android:layout_marginStart=\"10dp\"                    android:layout_gravity=\"center\"                    android:alpha=\"1\"                    android:text=\"@{name}\"                    android:textSize=\"15sp\"                    tools:text=\"Subtitle Placeholder\"                    tools:visibility=\"visible\" /&gt;            &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt;            &lt;androidx.appcompat.widget.AppCompatImageButton                android:id=\"@+id/switch_accessory\"                android:layout_width=\"24dp\"                android:layout_height=\"24dp\"                android:layout_marginStart=\"8dp\"                android:layout_marginEnd=\"16dp\"                android:background=\"@drawable/ic_star_user\"                android:clickable=\"@{true}\"                app:layout_constraintBottom_toBottomOf=\"parent\"                app:layout_constraintEnd_toEndOf=\"parent\"                app:layout_constraintStart_toEndOf=\"@id/group_title\"                app:layout_constraintTop_toTopOf=\"parent\" /&gt;            &lt;View                android:layout_width=\"match_parent\"                android:layout_height=\"0.5dp\"                android:layout_marginHorizontal=\"16dp\"                android:background=\"@color/app_std_separator_line\"                app:layout_constraintBottom_toBottomOf=\"parent\" /&gt;        &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;    &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt;&lt;/layout&gt;\n\n结果\n\n","categories":["有在认真上班"],"tags":["写了什么新功能"]},{"title":"添加记住密码功能","url":"/blog/2023/02/15/%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E5%AF%86%E7%A0%81%E5%8A%9F%E8%83%BD/","content":"操作编写界面交互代码res/layout/activity_login.xml\n&lt;CheckBox  android:id=\"@+id/remember_password\"  android:layout_width=\"wrap_content\"  android:layout_height=\"wrap_content\"  android:layout_marginHorizontal=\"24dp\"  android:layout_marginTop=\"8dp\"  android:textSize=\"12sp\"  android:minHeight=\"36dp\"  android:layout_gravity=\"right\"  android:text=\"@string/text_remember_me\"  android:onClick=\"@{viewModel::onClickRememberPassword}\"  app:layout_constraintRight_toRightOf=\"parent\"  app:layout_constraintStart_toStartOf=\"parent\"  app:layout_constraintTop_toBottomOf=\"@id/edit_password\"/&gt;\n\n\n记住密码框架封装com/danale/edge/coreimpl/usersdk/PvStoreImpl.kt\npackage com.danale.edge.coreimpl.usersdkimport android.content.Contextimport android.content.SharedPreferencesimport androidx.security.crypto.EncryptedSharedPreferencesimport androidx.security.crypto.MasterKeyimport com.danale.edge.foundation.log.Loggerimport com.danale.edge.usersdk.di.PvStoreRepositoryimport dagger.hilt.android.qualifiers.ApplicationContextimport javax.inject.Injectclass PvStoreImpl @Inject constructor(    @ApplicationContext private val context: Context) : PvStoreRepository {    companion object {        const val TAG = \"PvStoreImpl\"        const val SP_NAME = \"com.danale.edge.coreimpl.usersdk.PvStoreImpl\"    }  // 使用EncryptedSharedPreferences通过 Security 库以更安全的方式修改用户的一组共享偏好设置    private fun getEncryptedSp(): SharedPreferences {        val mainKey = MasterKey.Builder(context)            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)            .build()        return EncryptedSharedPreferences.create(            context,            SP_NAME,            mainKey,            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM        )    }    @Synchronized    override fun store(key: String, value: String) {        with(getEncryptedSp().edit()) {            putString(key, value)            apply()        }    }    @Synchronized    override fun read(key: String): String? {        return getEncryptedSp().getString(key, null)    }}\n\n添加点击checkbox时的绑定函数获取checkbox的选中状态\ncom/danale/edge/ui/account/LoginViewModel.kt\nprivate var acceptRememberMeState: Boolean = false@Suppress(\"UNUSED_PARAMETER\")    fun onClickRememberPassword(view: View) {        (view as? CheckBox)?.let {            acceptRememberMeState = it.isChecked        }    }\n\n在登录函数中添加逻辑如果checkbox被选中，就将用户名和密码存起来；否则置空\ncom/danale/edge/ui/account/LoginViewModel.kt\n// 初始化用户名和密码private var userName: String? = pvStoreImpl.read(\"userName\") private var password: String? = pvStoreImpl.read(\"password\")fun performLogin(licenseState: Boolean = acceptLicenseState) {  //  验证是否同意隐私条款  \t // ...    viewModelScope.launch {    // 验证用户名和密码的正确性      val success = withContext(Dispatchers.IO) {          try { } catch (ex: Exception) { }      }   // 验证成功    if (success) {     // 如果checkbox被选中则记住密码      if(acceptRememberMeState){        pvStoreImpl.store(\"userName\", userName!!)        pvStoreImpl.store(\"password\", password!!)      }else{        //  否则置空        pvStoreImpl.store(\"userName\", \"\")        pvStoreImpl.store(\"password\", \"\")      }    // 页面跳转    navigationRequiredEvent.postValue( )}//  用户名改变时监听状态fun afterUsernameChanged(editable: Editable) {    userName = editable.toString()    updateButtonEnable()  }//  密码改变时监听状态  fun afterPasswordChanged(editable: Editable) {    password = editable.toString()    updateButtonEnable()  }\n\n在初始化时显示存储的用户信息com/danale/edge/ui/account/LoginActivity.kt\nif(pvStoreImpl.read(\"userName\") != \"\" &amp;&amp; pvStoreImpl.read(\"password\") != \"\"){      dataBinding.editUserName.setText(pvStoreImpl.read(\"userName\"))      dataBinding.editPassword.setText(pvStoreImpl.read(\"password\"))      dataBinding.rememberPassword.isChecked = true      viewModel.updateButtonEnable()  }\n\n如果pvStoreImpl中有用户信息，将用户名和密码显示在editText内，同时设置checkbox的选中状态为true\nupdateButtonEnable用来更新登录按钮的状态，如果存在用户名和密码有为空的情况，则设置登录按钮不可点击状态\nfun updateButtonEnable() {    val isEmail = observableIsEmailUserName.get()    buttonEnable.set(!TextUtils.isEmpty(userName) &amp;&amp; !TextUtils.isEmpty(password) &amp;&amp; !isEmail)  }\n\n结果\n用到的库Security 库Security 库版本 1.1.0\nAPI 参考文档，可以安全地管理密钥并对文件和 sharedpreferences 进行加密androidx.security.crypto\nSecurity 库使用一个由两部分组成的密钥管理系统：\n\n包含一个或多个密钥的密钥集，用于对文件或共享偏好设置数据进行加密。密钥集本身存储在 SharedPreferences 中。\n\n用于加密所有密钥集的主 (master) 密钥。此密钥使用 Android 密钥库系统进行存储。\n\n库中包含的类\nSecurity 库包含以下类，旨在提供更安全的静态数据机制：\n\nEncryptedFile\n提供 FileInputStream 和 FileOutputStream 的自定义实现，为您的应用赋予更安全的流式读写操作。为了提供安全的文件流读写操作，Security 库使用了流式 AEAD（带关联数据的认证加密）基元。如需详细了解该基元，请参阅 GitHub 上的 Tink 库文档。\n\nEncryptedSharedPreferences\n封装 SharedPreferences 类，并使用双重方案方法自动加密密钥和值：\n​    密钥使用确定性加密算法进行加密，这样便可以加密并正确查找密钥。\n​    值使用 AES-256 GCM 加密，并且具有不确定性。\n\n\n\n\n读取文件使用 EncryptedFile 通过 Security 库以更安全的方式读取文件内容：\nval mainKey = MasterKey.Builder(applicationContext)        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)        .build()val fileToRead = \"my_sensitive_data.txt\"val encryptedFile = EncryptedFile.Builder(applicationContext,        File(DIRECTORY, fileToRead),        mainKey,        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB).build()val inputStream = encryptedFile.openFileInput()val byteArrayOutputStream = ByteArrayOutputStream()var nextByte: Int = inputStream.read()while (nextByte != -1) {    byteArrayOutputStream.write(nextByte)    nextByte = inputStream.read()}val plaintext: ByteArray = byteArrayOutputStream.toByteArray()\n\n写入文件使用 EncryptedFile 通过 Security 库以更安全的方式写入文件内容：\nval mainKey = MasterKey.Builder(applicationContext)        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)        .build()// 使用此名称创建文件，或替换具有相同名称的现有文件。 请注意，文件名不能包含路径分隔符。val fileToWrite = File(DIRECTORY, \"my_sensitive_data.txt\")val encryptedFile = EncryptedFile.Builder(applicationContext,        fileToWrite,        mainKey,        EncryptedFile.FileEncryptionScheme.AES256_GCM_HKDF_4KB).build()// 使用 openFileOutput 之前文件不能存在if (fileToWrite.exists()) {    fileToWrite.delete()}val fileContent = \"MY SUPER-SECRET INFORMATION\".toByteArray(StandardCharsets.UTF_8))encryptedFile.openFileOutput().apply {    write(fileContent)    flush()    close()}\n\n修改共享偏好设置使用 EncryptedSharedPreferences 通过 Security 库以更安全的方式修改用户的一组共享偏好设置：\nval context = applicationContextval mainKey = MasterKey.Builder(applicationContext)        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)        .build()val sharedPreferences = EncryptedSharedPreferences.create(    applicationContext,    FILE_NAME,    mainKey,    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM)with (sharedPreferences.edit()) {    //  修改共享偏好设置    apply()}\n\n\n\nMasterKey.Builder用于生成 MasterKey\nSummary\n\n\nPublic constructors\n\n\n\n\nBuilder(context: Context)\n使用默认别名 MasterKeyDEFAULT_MASTER_KEY_ALIAS创建一个构建器\n\n\nBuilder(context: Context, keyAlias: String)\n为 .MasterKey 创建构建器\n\n\n\n\n\nPublic functions\n\n\n\n\nMasterKey\nbuild()\n\n\nMasterKey.Builder\n@RequiresApi(value = Build.VERSION_CODES.M)setKeyGenParameterSpec(keyGenParameterSpec: KeyGenParameterSpec)设置自定义用作主密钥的基础KeyGenParameterSpec\n\n\nMasterKey.Builder\nsetKeyScheme(keyScheme: MasterKey.KeyScheme)设置用于主密钥的KeyScheme\n\n\nMasterKey.Builder\nsetRequestStrongBoxBacked(requestStrongBoxBacked: Boolean)设置是否请求此密钥是强框支持的\n\n\nMasterKey.Builder\nsetUserAuthenticationRequired(  authenticationRequired: Boolean,  userAuthenticationValidityDurationSeconds: @IntRange(from = 1) Int)设置构建的主密钥在解锁之前应要求用户进行身份验证，可能使用 androidx.biometric 库，并且密钥应在提供的持续时间内保持解锁状态.setKeyScheme\n\n\nMasterKey.Builder\nsetUserAuthenticationRequired(authenticationRequired: Boolean)设置构建的主密钥在解锁之前应要求用户进行身份验证，可能使用 androidx.biometric library.setKeyScheme\n\n\nPublic constructorsBuilderBuilder(context: Context)\n\n使用默认别名 .MasterKeyDEFAULT_MASTER_KEY_ALIAS 创建一个构建器     \n\n\n\nParameters\n\n\n\n\ncontext: Context\n与此主密钥一起使用的上下文\n\n\nBuilderBuilder(context: Context, keyAlias: String)\n\n为 .MasterKey 创建构建器\n\n\n\nParameters\n\n\n\n\ncontext: Context\n与此主密钥一起使用的上下文\n\n\nPublic functionsbuildfun build(): MasterKey\n\n从builder.MasterKey构建\n\n\n\nReturns\n\n\n\n\nMasterKey\n主key\n\n\n\n\n\nThrows\n\n\n\n\njava.security.GeneralSecurityException: java.security.GeneralSecurityException\n\n\n\njava.io.IOException: java.io.IOException\n\n\n\nsetKeyGenParameterSpec@RequiresApi(value = Build.VERSION_CODES.M)fun setKeyGenParameterSpec(keyGenParameterSpec: KeyGenParameterSpec): MasterKey.Builder\n\n设置自定义用作主密钥的基础。注意：应使用此方法或设置用于构建主密钥的参数。在另一个函数之后调用任一函数将抛出 .KeyGenParameterSpecsetKeySchemeIllegalArgumentException\n\n\n\nParameters\n\n\n\n\nkeyGenParameterSpec: KeyGenParameterSpec\n要使用的关键规范。\n\n\n\n\n\nReturns\n\n\n\n\nMasterKey.Builder\n构建器\n\n\nsetKeySchemefun setKeyScheme(keyScheme: MasterKey.KeyScheme): MasterKey.Builder\n\n设置要用于主密钥的 a。这使用与提供的关联的默认值。注意：应使用此方法或设置用于构建主密钥的参数。在另一个函数之后调用任一函数将抛出KeyScheme``KeyGenParameterSpec``KeyScheme``setKeyGenParameterSpec``IllegalArgumentException\n\n\n\nParameters\n\n\n\n\nkeyScheme: MasterKey.KeyScheme\nThe KeyScheme to use.\n\n\n\n\n\nReturns\n\n\n\n\nMasterKey.Builder\nThis builder.\n\n\nsetRequestStrongBoxBackedfun setRequestStrongBoxBacked(requestStrongBoxBacked: Boolean): MasterKey.Builder\n\n设置是否请求此密钥是强框支持的。此设置仅适用于以上版本，且仅适用于支持 Strongbox.P 的设备\n\n\n\nParameters\n\n\n\n\nrequestStrongBoxBacked: Boolean\nWhether to request to use strongbox\n\n\n\n\n\nReturns\n\n\n\n\nMasterKey.Builder\nThis builder.\n\n\nsetUserAuthenticationRequiredfun setUserAuthenticationRequired(    authenticationRequired: Boolean,    userAuthenticationValidityDurationSeconds: @IntRange(from = 1) Int): MasterKey.Builder\n\n与 一起使用时，设置构建的主密钥在解锁之前应要求用户进行身份验证，可能使用 androidx.biometric 库，并且密钥应在提供的持续时间内保持解锁状态setKeyScheme\n\n\n\nParameters\n\n\n\n\nauthenticationRequired: Boolean\nWhether user authentication should be required to use the key.\n\n\nuserAuthenticationValidityDurationSeconds: @IntRange(from = 1) Int\nDuration in seconds that the key should remain unlocked following user authentication.\n\n\n\n\n\nReturns\n\n\n\n\nMasterKey.Builder\nThis builder.\n\n\nsetUserAuthenticationRequiredfun setUserAuthenticationRequired(authenticationRequired: Boolean): MasterKey.Builder\n\n与 一起使用时，设置构建的主密钥在解锁之前应要求用户进行身份验证，可能使用 androidx.biometric 库。该方法设置key的有效期为.setKeyScheme getDefaultAuthenticationValidityDurationSeconds\n\n\n\nParameters\n\n\n\n\nauthenticationRequired: Boolean\n是否需要用户身份验证才能使用密钥\n\n\n\n\n\nReturns\n\n\n\n\nMasterKey.Builder\n构造器\n\n\n其他指纹登录安全样本/生物识别登录科特林在大师 ·安卓/安全示例 (github.com)\n","categories":["有在认真上班"],"tags":["改了什么bug"]},{"title":"直播界面适配平板大屏幕","url":"/blog/2023/02/27/%E7%9B%B4%E6%92%AD%E7%95%8C%E9%9D%A2%E9%80%82%E9%85%8D%E5%B9%B3%E6%9D%BF%E5%A4%A7%E5%B1%8F%E5%B9%95/","content":"概述内容直播界面适配平板大屏幕（车机屏幕）\n时间预计 2/15～2/17 + 2/20\n内容拆分\n检查登录页是否有显示异常（布局重叠）\n新增页面\n设备列表Activity（仅横屏，复用设备卡片网格布局，点击进入直播查看Activity）\n 直播查看Activity（仅横屏，只保留看直播视频功能）\n\n\n 临时修改跳转：启动APP直接进入新增的设备列表页\n功能对接\n参考现有的直播页，利用已有的代码实现\n 列表页点击卡片跳转设备直播页\n进入直播页面就加载直播视频\n加载失败的时候展示重试按钮（状态）\n对接现有的播放器手势操作：滑动到边缘控制云台\n\n\n\n参考\n强制Activity横屏或竖屏：https://blog.csdn.net/Smile_Qian/article/details/99187728\n\nrequestedOrientation = ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT\n\n\n卡片网格布局：https://www.cnblogs.com/guanxinjing/p/13037271.html\n\n界面跳转封装：com.danale.edge.base.BaseNavigation\n\n当前摄像头直播界面：com.danale.edge.ui.devicecontrol.ipc.IPCLiveFragment\n\n视频渲染View手势处理封装类：com.danale.edge.ui.common.view.ScaleTextureView\n\n设置点击图标拉起的启动Activity：\n&lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n\n测试账号15105982803\nApp_2021\n过程大概的逻辑\n\n主页面\n\nLandScapeListActivity作为主页面，在里面放置activity_land_scape_list设备列表\n\nactivity_land_scape_list中绑定对应的LandScapeListViewModel\n\nLandScapeListViewModel中设置onclick函数，通过路由跳转到直播页面\n\n\n\n直播页\n\nLandScapeIPCActivity作为直播的主页面，内部放置DeviceListToIPCFragment容器\n\n\n\n主页由于主页是通过Fragment切换动态创建的，所以首先创建一个新的Fragment放置设备列表\nLandScapeListActivity.kt创建主页的activity，绑定对应的xml布局文件\nui/devicelist/landscape/LandScapeListActivity.kt\npackage com.danale.edge.ui.devicelist.landscapeimport android.os.Bundleimport com.danale.edge.Rimport com.danale.edge.base.BaseActivityclass LandScapeListActivity : BaseActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_land_scape_list)  // 布局文件    }}\n\nactivity_land_scape_list.xmlactivity布局文件，内部套一个Fragment\nlayout/activity_land_scape_list.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    tools:context=\".ui.VideoFlowActivity\"&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:keepScreenOn=\"true\"        android:orientation=\"vertical\"        android:background=\"@color/black\"&gt;        &lt;androidx.fragment.app.FragmentContainerView            android:id=\"@+id/fragment_container\"            android:name=\"com.danale.edge.ui.devicelist.landscape.LandScapeListFragment\"            android:layout_width=\"match_parent\"            android:layout_height=\"match_parent\"            tools:layout=\"@layout/fragment_land_scape_list\" /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\nfragment_land_scape_list.xml创建主页的Fragment组件，通过variable实现数据绑定\n通过RecyclerView实现网格布局\nlayout/fragment_land_scape_list.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"viewModel\"            type=\"com.danale.edge.ui.devicelist.landscape.LandScapeListViewModel\" /&gt;    &lt;/data&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:background=\"@color/app_std_background_gray\"&gt;        &lt;com.danale.edge.ui.common.view.TopSafeAreaGuideLine            android:id=\"@+id/safe_area_top_guide\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"            app:layout_constraintGuide_begin=\"24dp\"            tools:ignore=\"MissingConstraints\" /&gt;        &lt;include            android:id=\"@+id/component_title_bar\"            layout=\"@layout/component_title_bar\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            app:layout_constraintTop_toBottomOf=\"@id/safe_area_top_guide\" /&gt;        &lt;androidx.recyclerview.widget.RecyclerView            android:id=\"@+id/recycler_view\"            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            app:layout_constraintTop_toBottomOf=\"@id/component_title_bar\" /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\nLandScapeListFragment.kt实现Fragment的布局和绑定，添加binding和ViewModel，在GridLayoutManager(requireContext(), 4)处设置布局样式\ncom/danale/edge/ui/devicelist/landscape/LandScapeListFragment.kt\npackage com.danale.edge.ui.devicelist.landscapeimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.databinding.DataBindingUtilimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.getimport androidx.recyclerview.widget.GridLayoutManagerimport com.danale.edge.Rimport com.danale.edge.base.BaseFragmentimport com.danale.edge.databinding.FragmentLandScapeListBindingimport com.danale.edge.usersdk.type.DeviceInfoclass LandScapeListFragment : BaseFragment() {    private lateinit var binding: FragmentLandScapeListBinding    private lateinit var viewModel: LandScapeListViewModel    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        logger.i(TAG, \"onCreateView\")        binding =            DataBindingUtil.inflate(inflater, R.layout.fragment_land_scape_list, container, false)  // 绑定数据        binding.lifecycleOwner = viewLifecycleOwner  // 生命周期        viewModel = ViewModelProvider(requireActivity()).get()  // 绑定ViewModel        observeNavigation(viewModel)  // 处理BaseViewModel的导航请求        binding.recyclerView.apply {            adapter = viewModel.adapterForClassCode(DeviceInfo.DEVICE_TYPE_IPC)            // 一行四列            layoutManager = GridLayoutManager(requireContext(), 4)        }        return binding.root    }    override fun onResume() {        super.onResume()        setStatusBarDarkText(true)  // 切换状态栏文本颜色,true为深色        viewModel.loadDeviceList()  // 加载设备列表    }}\n\nLandScapeListViewModel.ktViewModel文件，用来实现内部逻辑\ncom/danale/edge/ui/devicelist/landscape/LandScapeListViewModel.kt\npackage com.danale.edge.ui.devicelist.landscapeimport android.app.Applicationimport android.content.Intentimport com.danale.edge.base.BaseNavigationimport com.danale.edge.ui.devicelist.ListDeviceViewModelimport com.danale.edge.ui.devicelist.card.CardAdapterimport com.danale.edge.usersdk.type.DeviceInfoimport dagger.hilt.android.lifecycle.HiltViewModelimport javax.inject.Inject@HiltViewModelclass LandScapeListViewModel @Inject constructor(application: Application) :    ListDeviceViewModel(application), CardAdapter.Delegate {    /**     *跳转直播     */    override fun navigateDevicePage(item: DeviceInfo) {        val type = item.getDeviceType()        if (type != DeviceInfo.DEVICE_TYPE_IPC) return  // 判断设备类型        item.getDeviceInfoDid()?.let { did -&gt;            val intent = Intent().apply {                putExtra(BaseNavigation.Constants.EXTRA_PLATFORM_DEVICE_ID_32, did)                putExtra(                    BaseNavigation.Constants.EXTRA_PLATFORM_DEVICE_LIKE_NAME,                    item.getDeviceInfoLikeName()                )            }            navigationRequiredEvent.postValue(                BaseNavigation(                    BaseNavigation.Route.CONTROL_LAND_SCAPE_IPC,  // 进入直播页                    intent                )            )        }    }}\n\n直播页LandScapeIPCActivity.kt创建一个直播页的activity\ncom/danale/edge/ui/devicecontrol/landscape/LandScapeIPCActivity.kt\npackage com.danale.edge.ui.devicecontrol.landscapeimport android.os.Bundleimport androidx.activity.viewModelsimport com.danale.edge.Rimport com.danale.edge.base.BaseActivityimport com.danale.edge.base.BaseNavigationimport com.danale.edge.foundation.privacy.Fuzzyimport com.danale.edge.ui.devicecontrol.common.DeviceLiveViewModel/** * IPC入口Activity到直播页 */class LandScapeIPCActivity : BaseActivity() {    private val liveVm: DeviceLiveViewModel by viewModels()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_land_scape_ipc)  // 布局文件        intent?.let { intent -&gt;            intent.getStringExtra(BaseNavigation.Constants.EXTRA_PLATFORM_DEVICE_ID_32)                ?.let { did -&gt;                    logger.d(TAG, \"onCreate, did=${Fuzzy.interval(did)}\")                    liveVm.deviceId32 = did                }            intent.getStringExtra(BaseNavigation.Constants.EXTRA_PLATFORM_DEVICE_LIKE_NAME)                ?.let { name -&gt;                    logger.d(TAG, \"onCreate, name=${Fuzzy.interval(name)}\")                    liveVm.observableDeviceName.set(name)                }        }    }}\n\nactivity_land_scape_ipc.xmllayout/activity_land_scape_ipc.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".ui.devicecontrol.landscape.LandScapeIPCActivity\"&gt;    &lt;androidx.fragment.app.FragmentContainerView        android:id=\"@+id/fragment_container_ipc\"        android:name=\"com.danale.edge.ui.devicecontrol.landscape.LandScapeIPCLiveFragment\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        tools:layout=\"@layout/fragment_land_scape_ipc_live\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\nfragment_land_scape_ipc_live.xmllayout/fragment_land_scape_ipc_live.xmll\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"&gt;    &lt;data&gt;        &lt;variable            name=\"viewModel\"            type=\"com.danale.edge.ui.devicecontrol.common.DeviceLiveViewModel\" /&gt;        &lt;import type=\"android.view.View\" /&gt;    &lt;/data&gt;    &lt;androidx.constraintlayout.widget.ConstraintLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:background=\"@color/black\"&gt;\t\t\t\t      &lt;!--顶部安全距离--&gt;        &lt;com.danale.edge.ui.common.view.TopSafeAreaGuideLine            android:id=\"@+id/safe_area_top_guide\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:orientation=\"horizontal\"            app:layout_constraintGuide_begin=\"24dp\"            tools:ignore=\"MissingConstraints\" /&gt;        &lt;com.danale.edge.ui.common.view.ScaleTextureView            android:id=\"@+id/texture_view\"            android:layout_width=\"match_parent\"            android:layout_height=\"match_parent\" /&gt;        &lt;androidx.appcompat.widget.LinearLayoutCompat            android:layout_width=\"match_parent\"            android:layout_height=\"wrap_content\"            android:gravity=\"start\"            android:orientation=\"horizontal\"            android:paddingHorizontal=\"12dp\"            android:paddingVertical=\"4dp\"            android:visibility=\"visible\"            app:layout_constraintTop_toBottomOf=\"@id/safe_area_top_guide\"&gt;          &lt;!--返回按钮--&gt;            &lt;androidx.appcompat.widget.AppCompatImageView                android:id=\"@+id/iv_back_icon\"                android:layout_width=\"48dp\"                android:layout_height=\"48dp\"                android:layout_marginHorizontal=\"3dp\"                android:layout_marginVertical=\"15dp\"                android:padding=\"6dp\"                app:srcCompat=\"@mipmap/ic_back_white\" /&gt;        &lt;/androidx.appcompat.widget.LinearLayoutCompat&gt;      &lt;!--重新加载组件--&gt;        &lt;com.github.ybq.android.spinkit.SpinKitView            style=\"@style/SpinKitView.ThreeBounce\"            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:visibility=\"@{viewModel.observableVideoState.showLoadingUi ? View.VISIBLE : View.GONE}\"            app:SpinKit_Color=\"@color/white\"            app:layout_constraintBottom_toBottomOf=\"@id/texture_view\"            app:layout_constraintEnd_toEndOf=\"@id/texture_view\"            app:layout_constraintStart_toStartOf=\"@id/texture_view\"            app:layout_constraintTop_toTopOf=\"@id/texture_view\" /&gt;        &lt;androidx.appcompat.widget.AppCompatTextView            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:background=\"@drawable/bg_round_color\"            android:backgroundTint=\"@color/app_std_white_20\"            android:gravity=\"center\"            android:onClick=\"@{viewModel::onClickLoadLiveVideo}\"            android:paddingHorizontal=\"24dp\"            android:paddingVertical=\"8dp\"            android:text=\"@string/text_retry_loading\"            android:textColor=\"@color/white\"            android:visibility=\"@{viewModel.observableVideoState.showErrorUi ? View.VISIBLE : View.GONE}\"            app:layout_constraintBottom_toBottomOf=\"@id/texture_view\"            app:layout_constraintEnd_toEndOf=\"@id/texture_view\"            app:layout_constraintStart_toStartOf=\"@id/texture_view\"            app:layout_constraintTop_toTopOf=\"@id/texture_view\" /&gt;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;\n\n\nLandScapeIPCLiveFragment.ktcom/danale/edge/ui/devicecontrol/landscape/LandScapeIPCLiveFragment.kt\npackage com.danale.edge.ui.devicecontrol.landscapeimport android.content.res.Configurationimport android.graphics.SurfaceTextureimport android.os.Bundleimport android.view.*import androidx.activity.result.ActivityResultLauncherimport androidx.activity.result.contract.ActivityResultContractsimport androidx.databinding.DataBindingUtilimport androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.getimport com.danale.edge.Rimport com.danale.edge.base.BaseFragmentimport com.danale.edge.databinding.FragmentLandScapeIpcLiveBindingimport com.danale.edge.foundation.media.PcmTrackimport com.danale.edge.ui.common.view.ScaleTextureViewimport com.danale.edge.ui.devicecontrol.common.DeviceLiveViewModelimport com.danale.edge.usersdk.usecase.UserSdkUseCaseimport javax.inject.Inject/** * 直播页具体内容 */class LandScapeIPCLiveFragment : BaseFragment(), TextureView.SurfaceTextureListener {    private lateinit var binding: FragmentLandScapeIpcLiveBinding    private lateinit var viewModel: DeviceLiveViewModel    private lateinit var requestPermissionLauncher: ActivityResultLauncher&lt;String&gt;    private var surfaceCallback: ((Surface) -&gt; Unit)? = null    private var surface: Surface? = null    @Inject    lateinit var sdk: UserSdkUseCase    lateinit var deviceId32: String    override fun onCreateView(        inflater: LayoutInflater,        container: ViewGroup?,        savedInstanceState: Bundle?    ): View {        binding =            DataBindingUtil.inflate(                inflater,                R.layout.fragment_land_scape_ipc_live,                container,                false            )  // 数据绑定        binding.lifecycleOwner = viewLifecycleOwner  // 生命周期        viewModel = ViewModelProvider(requireActivity()).get()  // ViewModel（使用原有的        binding.viewModel = this.viewModel        deviceId32 = viewModel.deviceId32.toString()  // 获取设备id      // 云台控制        binding.textureView.surfaceTextureListener = this        binding.textureView.setCanTouch(true)        binding.textureView.setScaleTextureOnTouchLimitListener(object :            ScaleTextureView.ScaleTextureOnTouchLimitListener {            override fun onLeftLimit() {                logger.d(TAG, \"video gesture, left limit\")                viewModel.setPtzNeedStop(false)                viewModel.sendRequest(DeviceLiveViewModel.IPCDirection.LEFT)            }            override fun onRightLimit() {                logger.d(TAG, \"video gesture, right limit\")                viewModel.setPtzNeedStop(false)                viewModel.sendRequest(DeviceLiveViewModel.IPCDirection.RIGHT)            }            override fun onTopLimit() {                logger.d(TAG, \"video gesture, top limit\")                viewModel.setPtzNeedStop(false)                viewModel.sendRequest(DeviceLiveViewModel.IPCDirection.TOP)            }            override fun onBottomLimit() {                logger.d(TAG, \"video gesture, bottom limit\")                viewModel.setPtzNeedStop(false)                viewModel.sendRequest(DeviceLiveViewModel.IPCDirection.BOTTOM)            }            override fun onFinish() {                logger.d(TAG, \"video gesture, finish\")                viewModel.setPtzNeedStop(true)                viewModel.sendRequest(DeviceLiveViewModel.IPCDirection.STOP)            }            override fun onScale(scale: Float) {                logger.d(TAG, \"video gesture, scale $scale\")            }            override fun onOnlyClick() {                logger.d(TAG, \"video gesture, click\")                viewModel.toggleOverlayVisible()            }        })      // 返回按钮        binding.ivBackIcon.setOnClickListener {            onBackPressed()        }        requestPermissionLauncher =            registerForActivityResult(ActivityResultContracts.RequestPermission()) {                logger.d(TAG, \"mic permission result, it=$it\")            }        return binding.root    }    override fun onResume() {        super.onResume()        PcmTrack.startAudioTrackSync()        ensureSurface {            viewModel.startLive(it)        }    }    override fun onPause() {        super.onPause()        PcmTrack.releaseAudioTrackSync()        viewModel.releaseDeviceAndPlayer()    }    private fun ensureSurface(callback: (Surface) -&gt; Unit) {        val s = surface        if (s != null) {            callback(s)            return        } else {            surfaceCallback = callback        }    }    override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {        logger.i(TAG, \"onSurfaceTextureAvailable\")        val s = Surface(surface)        this.surface = s        surfaceCallback?.let {            it(s)        }        surfaceCallback = null    }    override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {        logger.i(TAG, \"onSurfaceTextureSizeChanged\")    }    override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {        logger.i(TAG, \"onSurfaceTextureDestroyed\")        this.surface = null        return true    }    override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {}    override fun onConfigurationChanged(newConfig: Configuration) {        super.onConfigurationChanged(newConfig)        viewModel.setOrientation(newConfig.orientation)    }}\n\n云台控制fun sendRequest(direction: IPCDirection) {        val did = deviceId32 ?: return        val thing = deviceThingInfo ?: return        viewModelScope.launch {            val stop = DpCommand(\"direction\", \"8\", \"1\")            val flipState = performOnIOWithDefault(DpFlipState.NORMAL) {                sdk.getDeviceFlipStatusWithCache(thing).await()            }          // 判断旋转的方向          // DpFlipState.UP_SIDE_DOWN是设备倒置的时候，需要调转方向            val request = when (direction) {                IPCDirection.LEFT -&gt; if (flipState == DpFlipState.UP_SIDE_DOWN) {                    DpCommand(\"direction\", \"8\", \"5\")                } else {                    DpCommand(\"direction\", \"8\", \"4\")                }                IPCDirection.RIGHT -&gt; if (flipState == DpFlipState.UP_SIDE_DOWN) {                    DpCommand(\"direction\", \"8\", \"4\")                } else {                    DpCommand(\"direction\", \"8\", \"5\")                }                IPCDirection.TOP -&gt; if (flipState == DpFlipState.UP_SIDE_DOWN) {                    DpCommand(\"direction\", \"8\", \"3\")                } else {                    DpCommand(\"direction\", \"8\", \"2\")                }                IPCDirection.BOTTOM -&gt; if (flipState == DpFlipState.UP_SIDE_DOWN) {                    DpCommand(\"direction\", \"8\", \"2\")                } else {                    DpCommand(\"direction\", \"8\", \"3\")                }                else -&gt; stop            }            withContext(Dispatchers.IO) {                try {                    sdk.commandDeviceDp(did, DpCode.PTZ_CONTROL, listOf(request)).await()                    if (ptzNeedStop.get()) {                        // 结果返回的时候操作已经停止了，为了避免设备一直转下去，在这种情况下发一个停止信令                        logger.w(TAG, \"ptz, control, need stop\")                        sdk.commandDeviceDp(did, DpCode.PTZ_CONTROL, listOf(stop)).await()                    }                } catch (e: Exception) {                    logger.e(TAG, \"ptz, control, error\", e)                    try {                        sdk.commandDeviceDp(did, DpCode.PTZ_CONTROL, listOf(stop)).await()                    } catch (_: Exception) {                    }                }            }        }    }// 在设备开始转的时候传入false，停止的时候传入true// 由于控制设备的方式是异步的，为了避免异步的顺序问题可能导致在停止后会收到旋转的消息，设备会一直转下去// 通过设定一个flag，在true的时候发送停止指令fun setPtzNeedStop(flag: Boolean){    ptzNeedStop.set(flag)}\n\n强制横屏Androidmanifest.xml中添加activity并设置intent-filter\n&lt;activity    android:name=\"com.danale.edge.ui.devicelist.landscape.LandScapeListActivity\"    android:exported=\"true\"    android:screenOrientation=\"landscape\"    android:configChanges=\"orientation|keyboardHidden\"&gt;     &lt;intent-filter&gt;         &lt;action android:name=\"android.intent.action.MAIN\" /&gt;         &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;     &lt;/intent-filter&gt;&lt;/activity&gt;\n\n","categories":["有在认真上班"],"tags":["写了什么新功能"]},{"title":"简单控件","url":"/blog/2023/02/28/%E7%AE%80%E5%8D%95%E6%8E%A7%E4%BB%B6/","content":"\n文本显示设置文本内容\n在 XML 文件中通过属性 android:text 设置文本，在XML文件中引用（@string/xxx）\n\n```xml- 在 Java 代码中调用文本视图对象的 setText 方法设置文本  引用字符串资源，在Java代码中引用（R.string.xxx）  - ```java    // 获取名为tv_hello的文本视图    TextView tv_hello = findViewById(R.id.tv_hello);    tv_hello.setText(\"你好，世界\"); // 设置tv_hello的文字内容\n\n\n\n设置文本的大小TextView允许设置文本内容，也允许设置文本大小，在Java代码中调用setTextSize方法，即可指定文本大小 \n// 从布局文件中获取名叫tv_sp的文本视图TextView tv_sp = findViewById(R.id.tv_sp);tv_sp.setTextSize(30); // 设置tv_sp的文本大小\n\nXML文件要求在字号数字后面写明单位类型，常见的字号单位主要有px、dp、sp 3种，分别介绍如下。\npxpx是手机屏幕的最小显示单位，它与设备的显示屏有关。一般来说，同样尺寸的屏幕（比如6英寸手机），如果看起来越清晰，则表示像素密度越高，以px计量的分辨率也越大。\ndpdp有时也写作dip，指的是与设备无关的显示单位，它只与屏幕的尺寸有关。一般来说，同样尺寸的屏幕以dp计量的分辨率是相同的，比如同样是6英寸手机，无论它由哪个厂家生产，其分辨率换算成dp单位都是一个大小。\nsp（推荐）sp的原理跟dp差不多，但它专门用来设置字体大小。手机在系统设置里可以调整字体的大小（小、标准、大、超大）。设置普通字体时，同数值dp和sp的文字看起来一样大；如果设置为大字体，用dp设置的文字没有变化，用sp设置的文字就变大了。\n字体大小采用不同单位的话，显示的文字大小各不相同。例如，30px、30dp、30sp这3个字号，在不同手机上的显示大小有所差异。有的手机像素密度较低，一个dp相当于两个px，此时30px等同于15dp；有的手机像素密度较高，一个dp相当于3个px，此时30px等同于10dp。假设某个App的内部文本使用字号30px，则该App安装到前一部手机的字体大小为15dp，安装到后一部手机的字体大小为10dp，显然后一部手机显示的文本会更小。  \n\n\n\n名称\n解释\n\n\n\npx（Pixel像 素）\n也称为图像元素，是作为图像构成的基本单元，单个像素的大小并不固定，跟随 屏幕大小和像素数量的关系变化，一个像素点为1px。\n\n\nResolution （分辨率）\n是指屏幕的垂直和水平方向的像素数量，如果分辨率是 1920*1080 ，那就是垂 直方向有 1920 个像素，水平方向有 1080 个像素。\n\n\nDpi（像素密 度）\n是指屏幕上每英寸（1英寸 = 2.54 厘米）距离中有多少个像素点。\n\n\nDensity（密 度）\n是指屏幕上每平方英寸（2.54 ^ 2 平方厘米）中含有的像素点数量。\n\n\nDip / dp (设 备独立像素)\n也可以叫做dp，长度单位，同一个单位在不同的设备上有不同的显示效果，具体 效果根据设备的密度有关，详细的公式请看下面 。\n\n\n设置文本的颜色// 从布局文件中获取名为tv_code_system的文本视图TextView tv_code_system = findViewById(R.id.tv_code_system);// 将tv_code_system的文字颜色设置系统自带的绿色tv_code_system.setTextColor(Color.GREEN);\n\n注意属性android:background和setBackgroundResource方法，它俩用来设置控件的背景，不单单是背景颜色，还包括背景图片。\n视图基础设置视图的宽高手机屏幕是块长方形区域，较短的那条边叫作宽，较长的那条边叫作高。App控件通常也是长方形状，控件宽度通过属性android:layout_width表达，控件高度通过属性android:layout_height表达，宽高的取值主要有下列3种：\n\nmatch_parent：表示与上级视图保持一致。上级视图的尺寸有多大，当前视图的尺寸就有多大。\nwrap_content：表示与内容自适应。对于文本视图来说，内部文字需要多大的显示空间，当前视图就要占据多大的尺寸。但最宽不能超过上级视图的宽度，一旦超过就要换行；最高不能超过上级视图的高度，一旦超过就会隐藏。\n以dp为单位的具体尺寸，比如300dp，表示宽度或者高度就是这么大。  \n\n设置视图的间距每个TextView标签都携带新的属性android:layout_marginTop=\"5dp\"，该属性的作用是让当前视图与上方间隔一段距离。同理，android:layout_marginLeft让当前视图与左边间隔一段距离，android:layout_marginRight让当前视图与右边间隔一段距离，android:layout_marginBottom让当前视图与下方间隔一段距离。如果上下左右都间隔同样的距离，还能使用android:layout_margin一次性设置四周的间距。\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- 最外层的布局背景为蓝色 --&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"300dp\"    android:background=\"#00AAFF\"    android:orientation=\"vertical\"&gt;    &lt;!-- 中间层的布局背景为黄色 --&gt;    &lt;LinearLayout        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_margin=\"20dp\"        android:background=\"#FFFF99\"        android:padding=\"60dp\"&gt;        &lt;!-- 最内层的视图背景为红色 --&gt;        &lt;View            android:layout_width=\"match_parent\"            android:layout_height=\"match_parent\"            android:background=\"#FF0000\"/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;\n\n\n\n设置视图的对齐方式在XML文件中通过属性android:layout_gravity可以指定当前视图的对齐方向，当属性值为top时表示视图朝上对齐，为bottom时表示视图朝下对齐，为left时表示视图靠左对齐，为right时表示视图靠右对齐。如果希望视图既朝上又靠左，则用竖线连接top与left，此时属性标记为android:layout_gravity=\"top|left\"；如果希望视图既朝下又靠右，则用竖线连接bottom与right，此时属性标记为android:layout_gravity=\"bottom|right\"。\n注意layout_gravity规定的对齐方式，指的是当前视图往上级视图的哪个方向对齐，并非当前视图的内部对齐。若想设置内部视图的对齐方向，则需由当前视图的android:gravity指定，该属性一样拥有top、bottom、left、right 4种取值及其组合。\ngravity与layout_gravity的不同之处在于：layout_gravity设定了当前视图相对于上级视图的对齐方式，而gravity设定了下级视图相对于当前视图的对齐方式；前者决定了当前视图的位置，而后者决定了下级视图的位置。\n常用布局线性布局LinearLayout线性布局像是用一根线把它的内部视图串起来，故而内部视图之间的排列顺序是固定的，要么从左到右排列，要么从上到下排列。\n在XML文件中，LinearLayout通过属性android:orientation区分两种方向，其中从左到右排列叫作水平方向，属性值为horizontal；从上到下排列叫作垂直方向，属性值为vertical。\n如果LinearLayout标签不指定具体方向，则系统默认该布局为水平方向排列，也就是默认android:orientation=\"horizontal\"  \n除了方向之外，线性布局还有一个权重概念，所谓权重，指的是线性布局的下级视图各自拥有多大比例的宽高，在XML文件中通过属性android:layout_weight来表达。  \n一旦设置了layout_weight属性值，便要求layout_width填0dp或者layout_height填0dp。如果layout_width填0dp，则layout_weight表示水平方向的权重，下级视图会从左往右分割线性布局；如果layout_height填0dp，则layout_weight表示垂直方向的权重，下级视图会从上往下分割线性布局。  \n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"&gt;    &lt;LinearLayout        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;        &lt;TextView            android:layout_width=\"0dp\"            android:layout_height=\"wrap_content\"            android:layout_weight=\"1\"            android:text=\"横排第一个\"            android:textSize=\"17sp\"            android:textColor=\"#000000\"/&gt;        &lt;TextView            android:layout_width=\"0dp\"            android:layout_height=\"wrap_content\"            android:layout_weight=\"1\"            android:text=\"横排第二个\"            android:textSize=\"17sp\"            android:textColor=\"#000000\"/&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:orientation=\"vertical\"&gt;        &lt;TextView            android:layout_width=\"wrap_content\"            android:layout_height=\"0dp\"            android:layout_weight=\"1\"            android:text=\"竖排第一个\"            android:textSize=\"17sp\"            android:textColor=\"#000000\"/&gt;        &lt;TextView            android:layout_width=\"wrap_content\"            android:layout_height=\"0dp\"            android:layout_weight=\"1\"            android:text=\"竖排第二个\"            android:textSize=\"17sp\"            android:textColor=\"#000000\"/&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;\n\n\n\n\n\n相对布局RelativeLayout线性布局的下级视图是顺序排列着的，另一种相对布局的下级视图位置则由其他视图决定。相对布局名为RelativeLayout，因为下级视图的位置是相对位置，所以得有具体的参照物才能确定最终位置。\n如果不设定下级视图的参照物，那么下级视图默认显示在RelativeLayout内部的左上角。用于确定下级视图位置的参照物分两种，一种是与该视图自身平级的视图；另一种是该视图的上级视图。\n\n属性值为true或者false\nandroid：layout_centerHrizontal 水平居中\nandroid：layout_centerVertical 垂直居中\nandroid：layout_centerInparent 相对于父控件完全居中\nandroid：layout_alignParentBottom 贴紧父控件的下边缘\nandroid：layout_alignParentLeft 贴紧父控件的左边缘\nandroid：layout_alignParentRight 贴紧父控件的右边缘\nandroid：layout_alignParentTop 贴紧父控件的上边缘\nandroid：layout_alignWithParentIfMissing 如果对应的兄弟控件找不到的话，就以父控件作为参照物\n\n\n属性值必须为id的引用名“@id/id-name”\nandroid：layout_below 在某控件下方\nandroid：layout_above 在某控件上方\nandroid：layout_toLeftOf 在某控件的左边\nandroid：layout_toRightOf 在某控件的右边\nandroid：layout_alignTop 本控件的上边缘和某控件的上边缘对齐\nandroid：layout_alignLeft 本控件的左边缘和某控件的左边缘对齐\nandroid：layout_alignBottom 本控件的下边缘和某控件的下控件对齐\nandroid：layout_alignRight 本控件的右边缘和某控件的有边缘对齐\n\n\n属性值为具体的像素值，如30dip，40px\nandroid：layout_marginBottom 离某控件底边缘的距离\nandroid：layout_marginLeft 离某控件左边缘的距离\nandroid：layout_marginRight 离某控件右边缘的距离\nandroid：layout_marginTop 离某控件上边缘的距离\n\n\n\n网格布局GridLayout网格布局默认从左往右、从上到下排列，它先从第一行从左往右放置下级视图，塞满之后另起一行放置其余的下级视图，如此循环往复直至所有下级视图都放置完毕。\n为了判断能够容纳几行几列，网格布局新增了android:columnCount与android:rowCount两个属性，其中columnCount指定了网格的列数，即每行能放多少个视图；rowCount指定了网格的行数，即每列能放多少个视图。  \n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;GridLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:columnCount=\"2\"    android:rowCount=\"2\"&gt;  &lt;!--两行两列--&gt;    &lt;TextView        android:layout_width=\"0dp\"        android:layout_height=\"60dp\"        android:layout_columnWeight=\"1\"        android:background=\"#ffcccc\"        android:gravity=\"center\"        android:text=\"浅红色\"        android:textColor=\"#000000\"        android:textSize=\"17sp\" /&gt;    &lt;TextView        android:layout_width=\"0dp\"        android:layout_height=\"60dp\"        android:layout_columnWeight=\"1\"        android:background=\"#ffaa00\"        android:gravity=\"center\"        android:text=\"橙色\"        android:textColor=\"#000000\"        android:textSize=\"17sp\" /&gt;    &lt;TextView        android:layout_width=\"0dp\"        android:layout_height=\"60dp\"        android:layout_columnWeight=\"1\"        android:background=\"#00ff00\"        android:gravity=\"center\"        android:text=\"绿色\"        android:textColor=\"#000000\"        android:textSize=\"17sp\" /&gt;    &lt;TextView        android:layout_width=\"0dp\"        android:layout_height=\"60dp\"        android:layout_columnWeight=\"1\"        android:background=\"#660066\"        android:gravity=\"center\"        android:text=\"深紫色\"        android:textColor=\"#000000\"        android:textSize=\"17sp\" /&gt;&lt;/GridLayout&gt;\n\n\n\n滚动视图ScrollView与线性布局类似，滚动视图也分为垂直方向和水平方向两类，其中垂直滚动视图名为ScrollView，水平滚动视图名为HorizontalScrollView。这两个滚动视图的使用并不复杂，主要注意以下3点：\n\n垂直方向滚动时，layout_width属性值设置为match_parent，layout_height属性值设置为wrap_content。\n水平方向滚动时，layout_width属性值设置为wrap_content，layout_height属性值设置为match_parent。\n滚动视图节点下面必须且只能挂着一个子布局节点，否则会在运行时报错Caused by： java.lang.IllegalStateException：ScrollView can host only one direct child。  \n\n有时ScrollView的实际内容不够，又想让它充满屏幕，再增加一行android:fillViewport（该属性为true表示允许填满视图窗口 \n android:layout_height=\"match_parent\"android:fillViewport=\"true\"\n\n按钮Button继承于TextView，因此它们拥有的属性都是共通的。\ntextAllCaps对于TextView来说，text属性设置了什么文本，文本视图就显示什么文本。但对于Button来说，不管text属性设置的是大写字母还是小写字母，按钮控件都默认转成大写字母显示。比如在XML文件中加入下面的Button标签  \n&lt;Button  android:layout_width=\"match_parent\"  android:layout_height=\"wrap_content\"  android:text=\"Hello World\"/&gt;\n\n编译运行后的App界面，按钮上显示全大写的“HELLO WORLD”，而非原来大小写混合的“HelloWorld”。显然这个效果不符合预期，为此需要给Button标签补充textAllCaps属性，该属性默认为true表示全部转为大写，如果设置为false则表示不转为大写。 \n&lt;Button  android:layout_width=\"match_parent\"  android:layout_height=\"wrap_content\"  android:text=\"Hello World\"  android:textAllCaps=\"false\"/&gt;\n\n\n\n点击事件除此之外，Button最重要的是点击事件。\n\n点击监听器：通过setOnClickListener方法设置。按钮被按住少于500毫秒时，会触发点击事件。\n\n```java// 从布局文件中获取名为btn_click_single的按钮控件Button btn_click_single = findViewById(R.id.btn_click_single);// 给btn_click_single设置点击监听器，一旦用户点击按钮，就触发监听器的onClick方法btn_click_single.setOnClickListener(new MyOnClickListener());// 定义一个点击监听器，它实现了接口View.OnClickListenerclass MyOnClickListener implements View.OnClickListener {  @Override  public void onClick(View v) { // 点击事件的处理方法String desc = String.format(\"%s 点击了按钮：%s\", ((Button) v).getText());\ntv_result.setText(desc); // 设置文本视图的文本内容\n\n  }}- 长按监听器：通过`setOnLongClickListener`方法设置。按钮被按住超过500毫秒时，会触发长按事件。  - ```java    // 从布局文件中获取名为btn_click_public的按钮控件    Button btn_longclick_public = findViewById(R.id.btn_longclick_public);    // 设置长按监听器，一旦用户长按按钮，就触发监听器的onLongClick方法    btn_longclick_public.setOnLongClickListener(this);        @Override    public boolean onLongClick(View v) { // 长按事件的处理方法      if (v.getId() == R.id.btn_longclick_public) { // 来自于按钮        btn_longclick_public        String desc = String.format(\"%s 长按了按钮：%s\", ((Button)v).getText());        tv_result.setText(desc); // 设置文本视图的文本内容      }       return true;    }\n\n\n\n点击监听器和长按监听器不局限于按钮控件，其实它们都来源于视图基类View，凡是从View派生而来的各类控件，均可注册点击监听器和长按监听器。譬如文本视图TextView，其对象也能调用setOnClickListener方法与setOnLongClickListener方法，此时TextView控件就会响应点击动作和长按动作。\n因为按钮存在按下和松开两种背景，便于提示用户该控件允许点击，但文本视图默认没有按压背景，不方便判断是否被点击，所以一般不会让文本视图处理点击事件和长按事件。  \n禁用与恢复按钮\n不可用按钮：按钮不允许点击，即使点击也没反应，同时按钮文字为灰色。\n可用按钮：按钮允许点击，点击按钮会触发点击事件，同时按钮文字为正常的黑色。  \n\nbtn_test.setEnabled(true); // 启用当前控件btn_test.setEnabled(false); // 禁用当前控件\n\n\n\n图像显示图片一般放在res/drawable目录下，设置图像显示一般有两种方法：\n\n在XML文件中，通过属性android:src设置图片资源，属性值格式形如 @drawable/不含扩展名的图片名称。\n在Java代码中，调用setImageResource方法设置图片资源，方法参数格式形如 R.drawable.不含扩展名的图片名称。（1）图像的缩放问题：ImageView本身默认图片居中显示，若要改变图片的显示方式，可通过scaleType属性设定，该属性的取值说明如下：\n\n图像视图ImageView由于图像通常保存为单独的图片文件，因此需要先把图片放到res/drawable目录，然后再去引用该图片的资源名称。XML文件通过属性android:src设置图片资源，属性值格式形如“@drawable/不含扩展名的图片名称”。  \n&lt;ImageView  android:id=\"@+id/iv_scale\"  android:layout_width=\"match_parent\"  android:layout_height=\"220dp\"  android:src=\"@drawable/apple\" /&gt;\n\nImageView本身默认图片居中显示，不管图片有多大抑或有多小，图像视图都会自动缩放图片，使之刚好够着ImageView的边界，并且缩放后的图片保持原始的宽高比例，看起来图片很完美地占据视图中央。这种缩放类型在XML文件中通过属性android:scaleType定义，即使图像视图未明确指定该属性，系统也会默认其值为fitCenter，表示让图像缩放后居中显示。  \n&lt;ImageView  android:id=\"@+id/iv_scale\"  android:layout_width=\"match_parent\"  android:layout_height=\"220dp\"  android:src=\"@drawable/apple\"  android:scaleType=\"fitCenter\"/&gt;\n\n在Java代码中可调用setScaleType方法设置图像视图的缩放类型，其中fitCenter对应的类型为ScaleType.FIT_CENTER\n// 将缩放类型设置为“保持宽高比例，缩放图片使其位于视图中间”iv_scale.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\n可选值如下：\n\nfitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变\nfitStart:保持纵横比缩放图片,知道较长的边与Image的边长相等,缩放完成后将图片放在ImageView的左上角\nfitCenter:同上,缩放后放于中间;\nfitEnd:同上,缩放后放于右下角;\ncenter:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。\ncenterCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全\ncenterInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片\nmatrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理\n\n图像按钮ImageButton：ImageButton是显示图片的图像按钮，但它继承自ImageView，而非继承Button。\nImageButton和Button之间的区别有：\n\nButton既可显示文本也可显示图片，ImageButton只能显示图片不能显示文本。\nImageButton上的图像可按比例缩放，而Button通过背景设置的图像会拉伸变形。\nButton只能靠背景显示一张图片，而ImageButton可分别在前景和背景显示图片，从而实现两张图片叠加的效果。\n\n同时展示文本与图像Button标签通过属性android:drawableTop设置了文字上边的图标，若想变更图标所处的位置，只要把drawableTop换成对应方向的属性即可\n\ndrawableTop：指定文字上方的图片。\ndrawableBottom：指定文字下方的图片。\ndrawableLeft：指定文字左边的图片。\ndrawableRight：指定文字右边的图片。\ndrawablePadding：指定图片与文字的间距。 \n\n ","categories":["有在认真上班"],"tags":["Android"]},{"title":"Activity","url":"/blog/2023/02/28/Activity/","content":"\n启停活动页面Activity的启动和结束从当前页面跳到新页面，跳转代码如下:startActivity(new lIntent(源页面.this,目标页面.class));\npackage com.dongnaoedu.chapter04;import androidx.appcompat.app.AppCompatActivity;import android.content.ComponentName;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;public class ActStartActivity extends AppCompatActivity implements View.OnClickListener {    private static final String TAG = \"ning\";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(TAG, \"ActStartActivity onCreate\");        setContentView(R.layout.activity_act_start);      \t// setOnClickListener来自于View，故而允许直接给View对象注册点击监听器        findViewById(R.id.btn_act_next).setOnClickListener(this);    }    @Override    public void onClick(View v) {   // 点击事件的处理方法        // 1.在Intent的构造函数中指定        //Intent intent = new Intent(this, ActFinishActivity.class);        // 2.调用意图对象的setClass方法指定        Intent intent = new Intent();        // intent.setClass(this,ActFinishActivity.class);        // 3.调用意图对象的setComponent方法指定        ComponentName component = new ComponentName(this, ActFinishActivity.class);        intent.setComponent(component);        startActivity(intent);    }}\n\n\n\n从当前页面回到上一个页面，相当于关闭当前页面，返回代码如下:finish();//结束当前的活动页面\n调用finish方法即可关闭当前页面，前述场景要求点击箭头图标或完成按钮都返回上一页面，则需给箭头图标和完成按钮分别注册点击监听器，然后在onClick方法中调用finish方法。  \n// 活动类直接实现点击监听器的接口View.OnClickListenerpublic class ActFinishActivity extends AppCompatActivity implements View.OnClickListener {  @Override  protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_act_finish);    // 给箭头图标注册点击监听器，ImageView由View类派生而来    findViewById(R.id.iv_back).setOnClickListener(this);    // 给完成按钮注册点击监听器，Button也由View类派生而来    findViewById(R.id.btn_finish).setOnClickListener(this);  }     @Override  public void onClick(View v) { // 点击事件的处理方法    if (v.getId() == R.id.iv_back || v.getId() == R.id.btn_finish) {      finish(); // 结束当前的活动页面    }  }}\n\n\n\n所谓“打开页面”或“关闭页面”沿用了浏览网页的叫法，对于App而言，页面的真实名称是“活动”—Activity。打开某个页面其实是启动某个活动，所以有startActivity方法却无openActivity方法；关闭某个页面其实是结束某个活动，所以有finish方法却无close方法。  \nActivity的生命周期\nApp引入活动的概念而非传统的页面概念，单从字面意思理解，页面更像是静态的，而活动更像是动态的。每次创建新的活动页面，自动生成的Java代码都给出了onCreate方法，该方法用于执行活动创建的相关操作，包括加载XML布局、设置文本视图的初始文字、注册按钮控件的点击监听，等等。onCreate方法所代表的创建动作，正是一个活动最开始的行为，除了onCreate，活动还有其他几种生命周期行为，它们对应的方法说明如下：\n\nonCreate：创建活动。此时会把页面布局加载进内存，进入了初始状态。\nonStart：开启活动。此时会把活动页面显示在屏幕上，进入了就绪状态。\nonResume：恢复活动。此时活动页面进入活跃状态，能够与用户正常交互，例如允许响应用户的点击动作、允许用户输入文字等。\nonPause：暂停活动。此时活动页面进入暂停状态（也就是退回就绪状态），无法与用户正常交互。\nonStop：停止活动。此时活动页面将不在屏幕上显示。\nonDestroy：销毁活动。此时回收活动占用的系统资源，把页面从内存中清除掉。\nonRestart：重启活动。处于停止状态的活动，若想重新开启的话，无须经历onCreate的重复创建过程，而是走onRestart的重启过程。\nonNewIntent：重用已有的活动实例。  \n\n如果一个Activity已经启动过，并且存在当前应用的Activity任务栈中，启动模式为singleTask，singleInstance或singleTop(此时已在任务栈顶端)，那么在此启动或回到这个Activity的时候，不会创建新的实例，也就是不会执行onCreate方法，而是执行onNewIntent方法。  \npublic class ActStartActivity extends AppCompatActivity implements View.OnClickListener {    \t@Override    protected void onCreate() {        super.onCreate();        Log.d(TAG, \"ActStartActivity onCreate\");    }    @Override    protected void onStart() {        super.onStart();        Log.d(TAG, \"ActStartActivity onStart\");    }    @Override    protected void onResume() {        super.onResume();        Log.d(TAG, \"ActStartActivity onResume\");    }    @Override    protected void onPause() {        super.onPause();        Log.d(TAG, \"ActStartActivity onPause\");    }    @Override    protected void onStop() {        super.onStop();        Log.d(TAG, \"ActStartActivity onStop\");    }    @Override    protected void onDestroy() {        super.onDestroy();        Log.d(TAG, \"ActStartActivity onDestroy\");    }    @Override    protected void onRestart() {        super.onRestart();        Log.d(TAG, \"ActStartActivity onRestart\");    }}\n\nonCreatonStartonResumeonPause  跳转到另外一个页面onStop  当前activity不可见onRestart  返回到当前activityonStartonResumeonPause  返回到桌面onStoponDestroy\n\n打开新页面的方法调用顺序为:onCreate→onStart→onResume关闭旧页面的方法调用顺序为:onPause→onStop→onDestroy\nActivity的启动模式系统给每个正在运行的App都分配了活动栈，栈里面容纳着已经创建且尚未销毁的活动信息。鉴于栈是一种先进后出、后进先出的数据结构，故而后面入栈的活动总是先出栈，假设3个活动的入栈顺序为：活动A→活动B→活动C，则它们的出栈顺序将变为：活动C→活动B→活动A，可见活动C结束之后会返回活动B，而不是返回活动A或者别的地方。\n假定某个App分配到的活动栈大小为3，该App先后打开两个活动，此时活动栈的变动情况如图所示\n\n\nAndroid允许在创建活动时指定该活动的启动模式，通过启动模式控制活动的出入栈行为。App提供了两种办法用于设置活动页面的启动模式，其一是修改AndroidManifest.xml，在指定的activity节点添加属性android:launchMode，表示本活动以哪个启动模式运行。其二是在代码中调用Intent对象的setFlags方法，表明后续打开的活动页面采用该启动标志。\n打开AndroidManifest.xml，给activity节点添加属性android:launchMode，属性值填入standard表示采取标准模式，当然不添加属性的话默认就是标准模式。具体的activity节点配置内容示例如下：\n&lt;activity android:name=\".JumpFirstActivity\" android:launchMode=\"standard\" /&gt;  \n\n\nStandard：标准模式，也是系统默认的启动模式。每次启动都会创建一个新的Activity实例，不管这个实例在栈中是否已经存上。Activity所在的任务栈为启动新Activity B的Activity A所在任务栈。具体就是Activity A所在的任务栈为S1，Activity A启动Activity B，那么Activty B的实例被创建后，会将Activity B的实例压入任务栈S1中。\n\nSingleTop：栈顶复用模式。在这种启动模式下，如果新Activity已经在任务栈的栈顶，那么，将不会重新创建新Activity，同时onNewIntent()方法被回调，通过此方法参数可以获取到请求信息。需要注意的是此Activity的onCreate()和onStart()方法也不会被调用。比如：有四个Activity，分别为ABCD，Activity D的LaunchMode是SingleTop模式；\n\n如果，在任务栈中四个Activity的排列是ABCD的顺序，此时，启动Activity D，由于Activity D位于任务栈栈顶，那么就不会创建Activity D实例，系统会调用Activity D的onNewIntent()方法。此时，Activity在任务栈中的顺序依然是ABCD。\n如果，在任务栈中四个Activity的排列是ADBC的顺序，此时，启动Activity D，由于Activity D没有位于任务栈栈顶，那么，就会创建Activity D的新实例，并压下任务栈中。此时，Activity在任务栈中的顺序是ADBCD。\n\n\nSingleTask：栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个任务栈中存在，那么多次启动此Activity都不会创建新的实例，和SingleTop一样，系统会调用其onNewIntent()方法。具体一点就是，有一个Activity A，并启动Activity A。首先寻找Activity A所需的任务栈，如果任务栈不存在，则创建任务栈并将Activity A压入栈中。如果Activity A所需的任务栈已经存在，则看Activity A在任务栈中，是否存在实例，如果不存在实例，就会创建新的实例并压入栈中；如果Activity A实例在已经存在的任务栈中，则将Activity A的实例调到栈顶，由于SingleTask有clearTop效果，在Activity A实例之上的所有Activity都会被出栈，直至Activity A到栈顶为止。比如：有四个Activity，分别为ABCD，并且Activity B的launchMode为SingleTask，此时启动Activity B。\n\n\n如果，Activity B所需的任务栈不存在，此时会创建其任务栈S1并将Activity B压入栈中。\n如果，Activity B所需的任务栈S1已经存在，此时会在任务栈S1中查看Activity B的实例是否在栈中存在。假如，Activity B的实例在任务栈S1中存在，并且当前任务栈中已经存在几个Activity，在任务栈中的排列为ABCD，那么，此时启动Activity B，不会再创建Activity B的实例，系统会调用其Activity B的onNewIntent()方法。并且将Activity B调至栈顶，由于SingleTask有clearTop效果，CD两个Activity会被出栈，直至Activity B被调到栈顶。\n如果，Activity B所需的任务栈S1已经存在，此时会在任务栈S1中查看是否存在Activity B的实例，如果不存在，则在任务栈S1中创建Activity B的实例，并压入任务栈S1中。\n\n\nSingleInstance：单实例模式。这是一种加强版的SingleTask模式，它除了具有SingleTask的所有特性外，还加强了一点，就是具有此模式的Activity只能单独位于一个任务栈中。换句话说就是，一个Activity B是SingleInstance模式，在启动Activity B时，会创建Activity B所需的任务栈S2，并将Activity B压入栈中，并且这个任务栈S2，只会有一个Activity，那就是Activity B。由于栈内复用模式，再次启动Activity B时，均不会再创建Activity B的实例，系统会调用Activity B的onNewIntent()方法。除非，Activity B所需的任务栈S2被系统销毁，否则不会再创建Activity B的实例。\n\n\nAndroid App在创建任务栈时，默认使用的是包名为任务栈名称，当前也可以自定义指定任务栈名称，比如：\n&lt;activity  android:name=\".SecondActivity\"  android:launchMode=\"singleInstance\"  android:taskAffinity=\"com.example.task.task.SecondActivity11\"  android:allowTaskReparenting=\"true\"/&gt;\n\n其中，属性taskAffinity与allowTaskReparenting是配合使用的，taskAffinity指定任务栈名称。属性taskAffinity只有在SingleTask和SingleInstance模式下有效。\n默认启动模式standard该模式可以被设定，不在 manifest 设定时候，Activity 的默认模式就是 standard。在该模式下，启动的 Activity 会依照启动顺序被依次压入 Task 栈中  \n\n栈顶复用模式 singleTop在该模式下，如果栈顶 Activity 为我们要新建的 Activity（目标Activity），那么就不会重复创建新的Activity  \n适合开启渠道多、多应用开启调用的 Activity，通过这种设置可以避免已经创建过的 Activity 被重复创建，多数通过动态设置使用  \n\n栈内复用模式 singleTask与 singleTop模式相似，只不过 singleTop 模式是只是针对栈顶的元素，而 singleTask 模式下，如果task 栈内存在目标 Activity 实例，则将 task 内的对应 Activity 实例之上的所有 Activity 弹出栈，并将对应 Activity 置于栈顶，获得焦点。  \n应用场景\n\n程序主界面：不希望主界面被创建多次，而且在主界面退出的时候退出整个 App 是最好的效果。\n耗费系统资源的Activity：对于那些及其耗费系统资源的 Activity，将其设为 singleTask模式，减少资源耗费。  \n\n\n全局唯一模式 singleInstance在该模式下，我们会为目标 Activity 创建一个新的 Task 栈，将目标 Activity 放入新的 Task，并让目标Activity获得焦点。新的 Task 有且只有这一个 Activity 实例。 如果已经创建过目标Activity 实例，则不会创建新的 Task，而是将以前创建过的 Activity 唤醒。\n\n动态设置启动模式通过 Intent 动态设置 Activity启动模式 ， 如果同时有动态和静态设置，那么动态的优先级更高。  \nintent.setFlags();\n\nFLAG_ACTIVITY_NEW_TASK跟 singleInstance 很相似，在给目标 Activity 设立此 Flag 后，会根据目标 Activity 的 affinity 进行匹配，如果已经存在与其affinity 相同的 task，则将目标 Activity 压入此 Task。反之没有的话，则新建一个 task，新建的 task 的 affinity 值与目标 Activity 相同，然后将目标 Activity 压入此栈。\n但它与 singleInstance 有不同的点，两点需要注意的地方：\n\n新的 Task 没有说只能存放一个目标 Activity，只是说决定是否新建一个 Task，而singleInstance模式下新的 Task 只能放置一个目标 Activity。\n在同一应用下，如果 Activity 都是默认的 affinity，那么此 Flag 无效，而singleInstance 默认情况也会创建新的 Task。  \n\nFLAG_ACTIVITY_SINGLE_TOP与静态设置中的 singleTop 效果相同  \nFLAG_ACTIVITY_CLEAR_TOP目标 Activity 会检查 Task 中是否存在此实例，如果没有则添加压入栈。如果有，就将位于 Task 中的对应 Activity 其上的所有 Activity 弹出栈，此时有以下两种情况：\n\n如果同时设置 Flag_ACTIVITY_SINGLE_TOP ，则直接使用栈内的对应 Activity。\n\n```javaintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);- 没有设置，则将栈内的对应 Activity 销毁重新创建。按位或运算符运算规则：0|0=0 0|1=1 1|0=1 1|1=1总结：参加运算的两个对象只要有一个为1，其值为1。例如：3|5即 0000 0011| 0000 0101 = 0000 0111，因此，3|5的值得7  # 在活动之间传递消息 ## 显式Intent和隐式IntentIntent就是传递消息，是各个组件之间信息沟通的桥梁既能在Activity之间沟通，又能在Activity与Service之间沟通，也能在Activity与Broadcast之间沟通。总而言之，Intent用于Android各组件之间的通信，它主要完成下列3部分工作：- 标明本次通信请求从哪里来、到哪里去、要怎么走。- 发起方携带本次通信需要的数据内容，接收方从收到的意图中解析数据。- 发起方若想判断接收方的处理结果，意图就要负责让接收方传回应答的数据内容  Intent的组成部分见表  | 元素名称  | 设置方法     | 说明与用途                        || --------- | ------------ | --------------------------------- || Component | setComponent | 组件，它指定意图的来源与目标      || Action    | setAction    | 动作，它指定意图的动作行为        || Data      | setData      | 即Uri，它指定动作要操纵的数据路径 || Category  | addCategory  | 类别，它指定意图的操作类别        || Type      | setType      | 数据类型，它指定消息的数据类型    || Extras    | putExtras    | 扩展信息，它指定装载的包裹信息    || Flags     | setFlags     | 标志位，它指定活动的启动标志      |指定意图对象的目标有两种表达方式，一种是显式Intent，另一种是隐式Intent。  ### 显式Intent直接指定来源活动与目标活动，属于精确匹配在构建一个意图对象时，需要指定两个参数，第一个参数表示跳转的来源页面，即“来源Activity.this”；第二个参数表示待跳转的页面，即“目标Activity.class”。具体的意图构建方式有如下3种：1. 在Intent的构造函数中指定，示例代码如下：   1. ```java      Intent intent = new Intent(this, ActNextActivity.class); // 创建一个目标确定的意图\n\n\n\n\n调用意图对象的setClass方法指定，示例代码如下：\n\n```javaIntent intent = new Intent(); // 创建一个新意图intent.setClass(this, ActNextActivity.class); // 设置意图要跳转的目标活动3. 调用意图对象的setComponent方法指定，示例代码如下：     1. ```java      Intent intent = new Intent(); // 创建一个新意图      // 创建包含目标活动在内的组件名称对象      ComponentName component = new ComponentName(this, ActNextActivity.class);      intent.setComponent(component); // 设置意图携带的组件信息\n\n\n\n隐式Intent没有明确指定要跳转的目标活动，只给出一个动作字符串让系统自动匹配，属于模糊匹配  \n通常App不希望向外部暴露活动名称，只给出一个事先定义好的标记串，这样大家约定俗成、按图索骥就好，隐式Intent便起到了标记过滤作用。这个动作名称标记串，可以是自己定义的动作，也可以是已有的系统动作。\n常见系统动作的取值说明见表  \n\n\n\nIntent 类的系统动作常量名\n系统动作的常量值\n说明\n\n\n\nACTION_MAIN\nandroid.intent.action.MAIN\nApp启动时的入口\n\n\nACTION_VIEW\nandroid.intent.action.VIEW\n向用户显示数据\n\n\nACTION_SEND\nandroid.intent.action.SEND\n分享内容\n\n\nACTION_CALL\nandroid.intent.action.CALL\n直接拨号\n\n\nACITON_DIAL\nandroid.intent.action.DIAL\n准备拨号\n\n\nACTION_SENDTO\nandroid.intent.action.SENDTO\n发送短信\n\n\nACTION_ANSWER\nandroid.intent.action.ANSWER\n接听电话\n\n\n动作名称既可以通过setAction方法指定，也可以通过构造函数Intent(String action)直接生成意图对象。当然，由于动作是模糊匹配，因此有时需要更详细的路径，比如仅知道某人住在天通苑小区，并不能直接找到他家，还得说明他住在天通苑的哪一期、哪栋楼、哪一层、哪一个单元。\nUri和Category便是这样的路径与门类信息，Uri数据可通过构造函数Intent(String action, Uri uri)在生成对象时一起指定，也可通过setData方法指定；Category可通过addCategory方法指定，之所以用add而不用set方法，是因为一个意图允许设置多个Category，方便一起过滤。  \nString phoneNo = \"12345\";Intent intent = new Intent(); // 创建一个新意图intent.setAction(Intent.ACTION_DIAL); // 设置意图动作为准备拨号Uri uri = Uri.parse(\"tel:\" + phoneNo); // 声明一个拨号的Uriintent.setData(uri); // 设置意图前往的路径startActivity(intent); // 启动意图通往的活动页面\n\n隐式Intent还用到了过滤器的概念，把不符合匹配条件的过滤掉，剩下符合条件的按照优先顺序调用。\n譬如创建一个App模块，AndroidManifest.xml里的intent-filter就是配置文件中的过滤器。像最常见的首页活动MainAcitivity，它的activity节点下面便设置了action和category的过滤条件。其中android.intent.action.MAIN表示App的入口动作，而android.intent.category.LAUNCHER表示在桌面上显示App图标，配置样例如下  \n&lt;activity android:name=\".MainActivity\"&gt;  &lt;intent-filter&gt;    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;  &lt;/intent-filter&gt;&lt;/activity&gt;\n\n\n\n向下一个Activity发送数据Intent对象的setData方法只指定到达目标的路径，并非本次通信所携带的参数信息，真正的参数信息存放在Extras中。Intent重载了很多种putExtra方法传递各种类型的参数，包括整型、双精度型、字符串等基本数据类型，甚至Serializable这样的序列化结构。只是调用putExtra方法显然不好管理，像送快递一样大小包裹随便扔，不但找起来不方便，丢了也难以知道。所以Android引入了Bundle概念，可以把Bundle理解为超市的寄包柜或快递收件柜，大小包裹由Bundle统一存取，方便又安全。\nBundle内部用于存放消息的数据结构是Map映射，既可添加或删除元素，还可判断元素是否存在。开发者若要把Bundle数据全部打包好，只需调用一次意图对象的putExtras方法；若要把Bundle数据全部取出来，也只需调用一次意图对象的getExtras方法。Bundle对象操作各类型数据的读写方法说明见表  \n\n\n\n数据类型\n读方法\n写方法\n\n\n\n整型数\ngetInt\nputInt\n\n\n浮点数\ngetFloat\nputFloat\n\n\n双精度数\ngetDouble\nputDouble\n\n\n布尔值\ngetBoolean\nputBoolean\n\n\n字符串\ngetString\nputString\n\n\n字符串数组\ngetStringArray\nputStringArray\n\n\n字符串列表\ngetStringArrayList\nputStringArrayList\n\n\n可序列化结构\ngetSerializable\nputSerializable\n\n\n一个活动之间传递数据的例子，首先在上一个活动使用包裹封装好数据，把包裹塞给意图对象，再调用startActivity方法跳到意图指定的目标活动  \n// 创建一个意图对象，准备跳到指定的活动页面Intent intent = new Intent(this, ActReceiveActivity.class);Bundle bundle = new Bundle(); // 创建一个新包裹// 往包裹存入名为request_time的字符串bundle.putString(\"request_time\", DateUtil.getNowTime());// 往包裹存入名为request_content的字符串bundle.putString(\"request_content\", tv_send.getText().toString());intent.putExtras(bundle); // 把快递包裹塞给意图startActivity(intent); // 跳转到意图指定的活动页面\n\n然后在下一个活动中获取意图携带的快递包裹，从包裹取出各参数信息，并将传来的数据显示到文本视图。  \n// 从布局文件中获取名为tv_receive的文本视图TextView tv_receive = findViewById(R.id.tv_receive);// 从上一个页面传来的意图中获取快递包裹Bundle bundle = getIntent().getExtras();// 从包裹中取出名为request_time的字符串String request_time = bundle.getString(\"request_time\");// 从包裹中取出名为request_content的字符串String request_content = bundle.getString(\"request_content\");String desc = String.format(\"收到请求消息：\\n请求时间为%s\\n请求内容为%s\",request_time, request_content);tv_receive.setText(desc); // 把请求消息的详情显示在文本视图上\n\n\n\n向上一个Activity返回数据数据传递经常是相互的，上一个页面不但把请求数据发送到下一个页面，有时候还要处理下一个页面的应答数据，所谓应答发生在下一个页面返回到上一个页面之际。如果只把请求数据发送到下一个页面，上一个页面调用startActivity方法即可；如果还要处理下一个页面的应答数据，此时就得分多步处理\n\n上一个页面打包好请求数据，调用startActivityForResult方法执行跳转动作，表示需要处理下一个页面的应答数据，该方法的第二个参数表示请求代码，它用于标识每个跳转的唯一性。  \n\n```javaString request = “你吃饭了吗？来我家吃吧”;// 创建一个意图对象，准备跳到指定的活动页面Intent intent = new Intent(this, ActResponseActivity.class);Bundle bundle = new Bundle(); // 创建一个新包裹// 往包裹存入名为request_time的字符串bundle.putString(“request_time”, DateUtil.getNowTime());// 往包裹存入名为request_content的字符串bundle.putString(“request_content”, request);intent.putExtras(bundle); // 把快递包裹塞给意图// 期望接收下个页面的返回数据。第二个参数为本次请求代码startActivityForResult(intent, 0);2. 下一个页面接收并解析请求数据，进行相应处理。     1. ```java      // 从上一个页面传来的意图中获取快递包裹      Bundle bundle = getIntent().getExtras();      // 从包裹中取出名为request_time的字符串      String request_time = bundle.getString(\"request_time\");      // 从包裹中取出名为request_content的字符串      String request_content = bundle.getString(\"request_content\");      String desc = String.format(\"收到请求消息：\\n请求时间为%s\\n请求内容为%s\",      request_time, request_content);      tv_request.setText(desc); // 把请求消息的详情显示在文本视图上\n\n\n下一个页面在返回上一个页面时，打包应答数据并调用setResult方法返回数据包裹。setResult方法的第一个参数表示应答代码（成功还是失败），第二个参数为携带包裹的意图对象。  \n\n```javaString response = “我吃过了，还是你来我家吃”;Intent intent = new Intent(); // 创建一个新意图Bundle bundle = new Bundle(); // 创建一个新包裹// 往包裹存入名为response_time的字符串bundle.putString(“response_time”, DateUtil.getNowTime());// 往包裹存入名为response_content的字符串bundle.putString(“response_content”, response);intent.putExtras(bundle); // 把快递包裹塞给意图// 携带意图返回上一个页面。RESULT_OK表示处理成功setResult(Activity.RESULT_OK, intent);finish(); // 结束当前的活动页面4. 上一个页面重写方法`onActivityResult`，该方法的输入参数包含请求代码和结果代码，其中请求代码用于判断这次返回对应哪个跳转，结果代码用于判断下一个页面是否处理成功。如果下一个页面处理成功，再对返回数据解包操作     1. ```java      // 从下一个页面携带参数返回当前页面时触发。其中requestCode为请求代码，      // resultCode为结果代码，intent为下一个页面返回的意图对象      @Override      protected void onActivityResult(int requestCode, int resultCode, Intent intent){ // 接收返回数据        super.onActivityResult(requestCode, resultCode, intent);        // 意图非空，且请求代码为之前传的0，结果代码也为成功        if (intent!=null &amp;&amp; requestCode==0 &amp;&amp; resultCode== Activity.RESULT_OK) {          Bundle bundle = intent.getExtras(); // 从返回的意图中获取快递包裹          // 从包裹中取出名叫response_time的字符串          String response_time = bundle.getString(\"response_time\");          // 从包裹中取出名叫response_content的字符串          String response_content = bundle.getString(\"response_content\");          String desc = String.format(\"收到返回消息：\\n应答时间为：%s\\n应答内容为：%s\",          response_time, response_content);          tv_response.setText(desc); // 把返回消息的详情显示在文本视图上        }      }\n\n\n\n为活动补充附加信息可以把字符串参数放到字符串资源文件中，待App运行之时再从资源文件读取字符串值；接着还能在AndroidManifest.xml中给指定活动配置专门的元数据，App运行时即可获取对应活动的元数据信息；然后利用元数据的resource属性配置更复杂的XML定义，从而为App注册在长按桌面之时弹出的快捷菜单。  \n利用资源文件配置字符串利用Bundle固然能在页面跳转的时候传送数据，但这仅限于在代码中传递参数，如果要求临时修改某个参数的数值，就得去改Java代码。然而直接修改Java代码有两个弊端：\n代码文件那么多，每个文件又有许多行代码，一下子还真不容易找到修改的地方。\n每次改动代码都得重新编译，让Android Studio编译的功夫也稍微费点时间。\n有鉴于此，对于可能手工变动的参数，通常把参数名称与参数值的对应关系写入配置文件，由程序在运行时读取配置文件，这样只需修改配置文件就能改变对应数据了。res\\values目录下面的strings.xml就用来配置字符串形式的参数，打开该文件，发现里面已经存在名为app_name的字符串参数，它配置的是当前模块的应用名称。现在可于app_name下方补充一行参数配置，参数名称叫作“weather_str”，参数值则为“晴天”，具体的配置内容如下所示：  \n&lt;string name=\"weather_str\"&gt;晴天&lt;/string&gt;\n\n接着打开活动页面的Java代码，调用getString方法即可根据R.string.参数名称获得指定参数的字符串值。  \n// 显示字符串资源private void showStringResource() {  String value = getString(R.string.weather_str); // 从strings.xml获取名叫weather_str的字符串值  tv_resource.setText(\"来自字符串资源：今天的天气是\"+value); // 在文本视图上显示文字}\n\n上面的getString方法来自于Context类，由于页面所在的活动类AppCompatActivity追根溯源来自Context这个抽象类，因此凡是活动页面代码都能直接调用getString方法。  \n利用元数据传递配置信息尽管资源文件能够配置字符串参数，然而有时候为安全起见，某个参数要给某个活动专用，并不希望其他活动也能获取该参数，此时就不方便到处使用getString了。\nActivity提供了元数据（Metadata）的概念，元数据是一种描述其他数据的数据，它相当于描述固定活动的参数信息。打开AndroidManifest.xml，在测试活动的activity节点内部添加meta-data标签，通过属性name指定元数据的名称，通过属性value指定元数据的值。仍以天气为例，添加meta-data标签之后的activity节点如下所示：\n&lt;activity android:name=\".MetaDataActivity\"&gt;\t&lt;meta-data android:name=\"weather\" android:value=\"晴天\" /&gt;&lt;/activity&gt;\n\n元数据的value属性既可直接填字符串，也可引用strings.xml已定义的字符串资源，引用格式形如@string/字符串的资源名称。下面便是采取引用方式的activity节点配置：\n&lt;activity android:name=\".MetaDataActivity\"&gt;  &lt;meta-data  android:name=\"weather\"  android:value=\"@string/weather_str\" /&gt;&lt;/activity&gt;\n\n配置好了activity节点的meta-data标签，再回到Java代码获取元数据信息，获取步骤分为下列3步：\n\n调用getPackageManager方法获得当前应用的包管理器。\n调用包管理器的getActivityInfo方法获得当前活动的信息对象。\n活动信息对象的metaData是Bundle包裹类型，调用包裹对象的getString即可获得指定名称的参数值。\n\n// 显示配置的元数据private void showMetaData() {  try {    PackageManager pm = getPackageManager(); // 获取应用包管理器    // 从应用包管理器中获取当前的活动信息    ActivityInfo act = pm.getActivityInfo(getComponentName(),PackageManager.GET_META_DATA);    Bundle bundle = act.metaData; // 获取活动附加的元数据信息    String value = bundle.getString(\"weather\"); // 从包裹中取出名叫weather的字符串    tv_meta.setText(\"来自元数据信息：今天的天气是\"+value); // 在文本视图上显示文字  } catch (Exception e) {    e.printStackTrace();  }}\n\n给应用页面注册快捷方式元数据不单单能传递简单的字符串参数，还能传送更复杂的资源数据  \n元数据的meta-data标签除了name属性和value属性，还拥有resource属性，该属性可指定一个XML文件，表示元数据想要的复杂信息保存于XML数据之中  \n借助元数据以及指定的XML配置可以完成快捷方式功能\n首先打开res/values目录下的strings.xml，在resources节点内部添加下述的3组（每组两个，共6个）字符串配置，每组都代表一个菜单项，每组又分为长名称和短名称，平时优先展示长名称，当长名称放不下时才展示短名称。这3组6个字符串的配置定义示例如下  \n&lt;string name=\"first_short\"&gt;first&lt;/string&gt;&lt;string name=\"first_long\"&gt;启停活动&lt;/string&gt;&lt;string name=\"second_short\"&gt;second&lt;/string&gt;&lt;string name=\"second_long\"&gt;来回跳转&lt;/string&gt;&lt;string name=\"third_short\"&gt;third&lt;/string&gt;&lt;string name=\"third_long\"&gt;登录返回&lt;/string&gt;\n\n接着在res目录下创建名为xml的文件夹，并在该文件夹创建shortcuts.xml，这个XML文件用来保存3组菜单项的快捷方式定义  \n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;    &lt;shortcut        android:enabled=\"true\"        android:icon=\"@mipmap/ic_launcher\"        android:shortcutId=\"first\"        android:shortcutLongLabel=\"@string/first_long\"        android:shortcutShortLabel=\"@string/first_short\"&gt;        &lt;intent            android:action=\"android.intent.action.VIEW\"            android:targetClass=\"com.dongnaoedu.chapter04.ActStartActivity\"            android:targetPackage=\"com.dongnaoedu.chapter04\" /&gt;        &lt;categories android:name=\"android.shortcut.conversation\" /&gt;    &lt;/shortcut&gt;    &lt;shortcut        android:enabled=\"true\"        android:icon=\"@mipmap/ic_launcher\"        android:shortcutId=\"second\"        android:shortcutLongLabel=\"@string/second_long\"        android:shortcutShortLabel=\"@string/second_short\"&gt;        &lt;intent            android:action=\"android.intent.action.VIEW\"            android:targetClass=\"com.dongnaoedu.chapter04.JumpFirstActivity\"            android:targetPackage=\"com.dongnaoedu.chapter04\" /&gt;        &lt;categories android:name=\"android.shortcut.conversation\" /&gt;    &lt;/shortcut&gt;    &lt;shortcut        android:enabled=\"true\"        android:icon=\"@mipmap/ic_launcher\"        android:shortcutId=\"third\"        android:shortcutLongLabel=\"@string/third_long\"        android:shortcutShortLabel=\"@string/third_short\"&gt;        &lt;intent            android:action=\"android.intent.action.VIEW\"            android:targetClass=\"com.dongnaoedu.chapter04.LoginInputActivity\"            android:targetPackage=\"com.dongnaoedu.chapter04\" /&gt;        &lt;categories android:name=\"android.shortcut.conversation\" /&gt;    &lt;/shortcut&gt;&lt;/shortcuts&gt;\n\n由上述的XML例子中看到，每个shortcut节点都代表了一个菜单项，该节点的各属性说明如下：\n\nshortcutId：快捷方式的编号。\nenabled：是否启用快捷方式。true表示启用，false表示禁用。\nicon：快捷菜单左侧的图标。\nshortcutShortLabel：快捷菜单的短标签。\nshortcutLongLabel：快捷菜单的长标签。优先展示长标签的文本，长标签放不下时才展示短标签的文本。\n\n以上的节点属性仅仅指明了每项菜单的基本规格，点击菜单项之后的跳转动作还要由shortcut内部的intent节点定义，该节点主要有targetPackage与targetClass两个属性需要修改，其中targetPackage属性固定为当前App的包名，而targetClass属性描述了菜单项对应的活动类完整路径。\n然后打开AndroidManifest.xml，找到MainActivity所在的activity节点，在该节点内部补充如下的元数据配置，其中name属性为android.app.shortcuts，而resource属性为@xml/shortcuts：\n&lt;meta-data android:name=\"android.app.shortcuts\"android:resource=\"@xml/shortcuts\"/&gt;\n\n这行元数据的作用，是告诉App首页有个快捷方式菜单，其资源内容参见位于xml目录下的shortcuts.xml。完整的activity节点配置示例如下  \n&lt;activity android:name=\".MainActivity\"&gt;  &lt;intent-filter&gt;    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;  &lt;/intent-filter&gt;  &lt;!-- 指定快捷方式。在桌面上长按应用图标，就会弹出@xml/shortcuts所描述的快捷菜单 --&gt;  &lt;meta-data    android:name=\"android.app.shortcuts\"    android:resource=\"@xml/shortcuts\" /&gt;&lt;/activity&gt;\n\n\n","categories":["有在认真上班"],"tags":["Android"]}]